# 第一部分  Linux命令行

## 1.初识Linux shell

### 1.1.Linux划分

* Linux内核
* GNU工具
* 图形化桌面环境
* 应用软件

<img src="..\Linux命令行与shell脚本大全\img\Linux系统.png">

### 1.2.内核的功能

* 系统内存管理
* 软件程序管理
* 硬件设备管理
* 文件系统管理

#### 1.2.1.系统内存管理

内核使用硬盘上的存储空间实现虚拟内存，这块区域叫做交换空间。内核不断地在交换空间和实际物理空间之间反复交换虚拟内存中的内容。

<img src="..\Linux命令行与shell脚本大全\img\Linux内存映射.png">

#### 1.2.2.软件程序管理

Linux发行版使用一个表来管理系统开机时要自动启动的进程。这个表位于专门文件/etc/inittab中。

Linux系统有5个运行级。

运行级为1时，只能启动基本的系统进程以及一个控制台终端进程。称为单用户模式。标准的启动运行级是3级，在这个运行级上大多数应用软件都会启动。

运行级5级，允许用户用图形化窗口登录系统。

### 1.2.3.硬件设备管理

Linux内核中两种方法用于插入设备驱动代码：

* 编译进内核的设备驱动代码
* 可插入内核的设备驱动模块

Linux系统将硬件设备当成特殊文件，称为设备文件。设备文件有三种分类：

* 字符型设备文件
* 块设备文件
* 网络设备文件

#### 1.2.4.文件系统管理

Linux内核采用虚拟文件系统作为和每个文件系统的接口。

| 文件系统 | 描述                                              |
| -------- | ------------------------------------------------- |
| ext      | Linux扩展文件系统，最早的Linux文件系统            |
| ext2     | 第二扩展文件系统                                  |
| ext3     | 第三扩展文件系统，支持日志功能                    |
| ext4     | 第四扩展文件系统，支持高级日志功能                |
| hpfs     | OS/2高性能文件系统                                |
| jfs      | IBM日志文件系统                                   |
| iso9660  | ISO  9660文件系统（CD-ROM）                       |
| minix    | MINIX文件系统                                     |
| msdos    | 微软的FAT16                                       |
| ncp      | Netware文件系统                                   |
| nfs      | 网络文件系统                                      |
| ntfs     | 支持Microsoft NT文件系统                          |
| proc     | 访问系统信息                                      |
| ReiserFS | 高级Linux文件系统，能提供更好的性能和硬盘恢复功能 |
| smb      | 支持网络访问的Samba SMB文件系统                   |
| sysv     | 较早期的Unix文件系统                              |
| ufs      | BSD文件系统                                       |
| umsdos   | 建立在msdos上的类Unix文件系统                     |
| vfat     | Windows 95文件系统（FAT32）                       |
| XFS      | 高性能64位日志文件系统                            |

### 1.3.GNU工具

#### 1.3.1.核心GNU工具

* 用于处理文件的工具
* 用于操作文本的工具
* 用于管理进程的工具

#### 1.3.2.shell

GUN为Linux开发了bash shell。

其他一些shell

| shell |                                                              |
| ----- | ------------------------------------------------------------ |
| ash   | 运行在内核受限环境中简单的轻量级shell，与bash shell完全兼容  |
| korn  | 与Bourne shell兼容的编程shell，支持关联数组和浮点运算        |
| tcsh  | 将c语言中的一些元素引入到shell脚本中的shell                  |
| zsh   | 结合了bash、tcsh和kron的特性，同时提供高级编程特性、共享历史文件和主题化提示符的高级shell |

### 1.4.Linux桌面环境

1. X Windiws
2. KDE
3. GNOME
4. Unity

### 1.5.Linux发行版

核心发行版

1. Slackware      最早的Linux发行版之一
2. Red Hat          用于Internet服务器的商业发行版
3. Fedora            从Red Hat分离出的家用发行版
4. Gentoo           为高级Linux用户设计的发行版，仅包含Linux源代码
5. openSUSE      用于商业和家用的发行版
6. Debain 

## 2. 走进shell

### 2.1.CLI

在图形化桌面出现以前，与Unix系统进行交互的唯一方式就是借助有shell所提供的文本命令行界面（Command line interface，CLI）。

图像化终端

终端仿真包

通过登录Linux控制台，进入CLI。

```BASH
$ setterm -inversescreen on  # 将终端的背景设置为白色、文本设置为黑色
$ setterm -inversescreen off # 关闭
```

setterm 选项

| 选项           | 参数                                                  | 描述                                           |
| -------------- | ----------------------------------------------------- | ---------------------------------------------- |
| -background    | black、red、green、yellow、blue、magenta、cyan、white | 将终端的背景色改为指定颜色                     |
| -foreground    | black、red、green、yellow、blue、magenta、cyan、white | 将终端的前景色改为指定颜色                     |
| -inversescreen | off、on                                               | 交换背景色和前景色                             |
| -reset         | 无                                                    | 将终端外观恢复成默认设置并清屏                 |
| -store         | 无                                                    | 将终端当前的前景色和背景色设置成-reset选项的值 |

### 2.2.图形化终端仿真访问CLI

* GNOME Terminal
* Konsole Terminal
* xterm

## 3.基本的bash shell命令

### 3.1.启动shell

/etc/passwd文件包含了所有系统用户账户列表以及每个用户的基本配置信息。每个条目包含7个字段字段之间用冒号隔开。

```bsah
turing:x:1000:1000:alan turing:/home/turing:/bin/bash
```

最后一个字段指定了该用户的默认shell，用户登录成功后默认启动。

### 3.2.bash手册

man命令用于访问Linux系统上的手册页面。手册页由分页程序（pager）来显示。

如查看ls命令:

```bash
$ man ls
```

**手册节名**

| 节            | 描述                       |
| ------------- | -------------------------- |
| Name          | 显示命令名和一段简短的描述 |
| Synopsis      | 命令的语法                 |
| Configuration | 命令的配置信息             |
| Description   | 命令的一般性描述           |
| Options       | 命令的选项描述             |
| Exit Status   | 命令的退出状态指示         |
| Return Value  | 命令的返回值               |
| Errors        | 命令的错误消息             |
| Environment   | 描述所使用的环境变量       |
| Files         | 命令使用到的文件           |
| Versions      | 命令的版本信息             |
| Conforming To | 命令所遵守的标准           |
| Notes         | 其他有帮助的资料           |
| Bugs          | 提交bug的途径              |
| Example       | 展示命令的用法             |
| Authors       | 命令的开发人员信息         |
| Copyright     | 命令源代码的版本状况       |
| See Also      | 与该命令相似的其他命令     |

查找命令

```bash
$ man -k "关键字"

$ man -k treminal   # 与系统相关的命令
```

### 3.3.Linux文件系统

Linux将文件存储在单个目录结构中，这个目录被称为虚拟目录（virtual directory）。

Linux会在根驱动器上创建一些特别的目录，称为挂载点（mount point）。

<img src="..\Frank_Linux\img\Linux目录.png"/> 

常见的目录名均基于文件系统层级标准（Filesystem Hierarchy Standard，FHS）。<a href="http://www.pathname.com/fhs">官方主页</a>

### 3.4.cd

**cd**命令将shell会话切换到另一个目录。

**cd**命令支持两种参数

* 相对路径
* 绝对路径
* . 单点符表示当前目录
* ..  双点符表示当前目录的父目录

```bash
$ cd /etc

$ cd ..     # 回到上一级目录

$ cd ../..  # 回到上上一级目录

$ cd        # 回到用户目录，root用户为/root
```

### 3.5.pwd

打印当前位置的目录的绝对路径

```bash
$ pwd
```

### 3.6.ls

#### 3.6.1.基本使用

查看当前目录下的文件和文件夹

ls命令输出的列表按字母排序（按列排序）。

```bash
$ ls
```

-F 参数用于区分文件和文件夹

```bash
$ ls -F
```

-a 参数用于显示隐藏文件

```bash
$ ls -a
```

-R 参数会递归的显示所有文件和文件夹

```bash
$ ls -R
```

合并使用

```bash
$ ls -FR
```

#### 3.6.2.显示长列表

-l 参数会显示文件信息，并产生长列表格式输出。

```bash
$ ls -l
```

<img src="..\Linux命令行与shell脚本大全\img\文件信息.png" />

**字段依次表示为：**

* **文件的类型，目录(d)、文件(-)、字符型文件(c)、块设备(b)、链接文件(l)；**
* **文件的权限，三位一组，分别为创建的用户、用户所属的组、其他用户**
* **文件的硬链接总数**
* **文件属主的用户名**
* **文件组的组名**
* **文件的大小（以字节为单位）**
* **文件上次修改的事件**
* **文件名或目录名**

#### 3.6.3.过滤文件

* **？问号代表一个字符**
* ***星号代表0个或多个字符**
* **[a..] 匹配方括号中的单个字符**
* **[a-z] 匹配方括号中的单个字符**
* **[!a]将不需要的字符排除**

**--time=atime**显示文件的访问时间

```bash
$ ls -l --time=atime Test.java
```

### 3.7.touch

**touch**命令用于创建空文件

```bash
$ touch Test.java
```

```bash
$ touch 1.java 2.c 3.cpp       # 一次创建多个空文件
```

**touch**命令可以改变文件的修改事时间。此操作并不改变文件内容。

**touch -a** 改变文件的访问时间。

### 3.8.cp

复制文件。

基本用法，cp命令需要两个参数——源对象和目标对象

如果源对象和目标对象都是文件，则源文件覆盖目标文夹

```bash
$ cp -i 1.java ../test/          # 复制文件到test目录下
```

-i  参数询问你是否执行此操作。

-R   可以用来复制文件夹及包含的所有文件

```bash
$ cp -R project test/           # project是一个文件夹
```

cp命令可以使用通配符

```bash
$ cp *.java  src/              # 复制所有java文件到src目录下
```

***对于文件名复杂的文件，使用Tab键自动补全文件名称***

### 3.9.链接文件

>  两种类型的文件链接：
>
> * 符号链接
> * 硬链接

要为一个文件创建符号链接，原始文件必须事先存在。链接文件是独立的文件。符号链接的名字位于ln命令的第二个参数位置上。

```bash
$ ln -s file  ln_file
```

创建硬链接。硬链接会创建独立的虚拟文件，其中包含原始文件的信息及位置，它们从根本上而言是同一个文件。引用硬链接等同引用了源文件。

```bash
$ ln file  ln_file
```

### 3.10.mv

**mv**命令可以重命名文件

```bash
$ mv lod_fileName  new_fileName
```

mv命令移动文件位置

```bash
$ mv file  ~/Document/
```

mv命令移动文件并重命名

```bash
$ mv fileName  ~/Document/fileName
```

mv命令移动整个目录及其内容

 ```bash
 $ mv dir ~/Document/
 ```

### 3.11.rm

删除文件或文件夹。-i参数提示是否真要删除文件。（好习惯）

```bash
$ rm -i file
```

-f 参数越过提示信息直接删除

```bash
$ rm -f file
```

-r 删除目录

```bash
$ rm -r dir
```

删除目录并越过提示

```bash
$ rm -rf dir
```

**rm**命令支持通配符

### 3.12.mkdir

创建一个空目录

```BASH
$ mkdir dirName
```

创建多级目录

```bash
$ mkdir -p src/java/
```

### 3.13.rmdir

**rmdir**只能删除空目录。

```bash
$ rmdir project
```

### 3.14.file

**file**命令可以查看文件的类型和编码。

```bash
$ file ln_file
```

### 3.15.cat

**cat**命令展示文件的文本内容。

-n参数会对每一行加上行号。

-b参数只对有文本信息的行加上行号。

-T参数用^I字符代替文本中的所有制表符。

### 3.16.more

**more**命令会显示文本的内容，但会在显示每页数据后停下来。

```bash
$ more file
```

### 3.17.less

**less**是**more**的升级版，实现文本前后翻页和支持搜索文本。

```bash
$ less file
```

### 3.18.tail

**tail**命令会显示文件最后几行的内容，默认为10行。-n参数指定行数。

```bash
$ tail -n 4 logFile
```

或

```bash
$ tail -4 logFile
```

### 3.19.head

**head**命令会显示文件前几行的内容，默认为10行。-n参数指定行数。

```bash
$ head -n 4 logFile
```

或

```bash
$ head -4 logFile
```

## 4.更多的bash shell命令

### 4.1.ps

**ps**命令可以输出系统上的所有进程的许多信息。

```bash
$ ps
```

<img src="..\Linux命令行与shell脚本大全\img\ps进程信息.png">

上例输出了进程的ID（Process ID，PID）、它们运行在哪个终端（TTY）以及进程以用的CPU时间。

<hr />

>  ps命令支持3种不同类型的命令行参数：
>
>  * Unix风格的参数，前面加单破折线
>  * BSD风格的参数，前面不加破折线
>  * GNU风格的长参数，前面加双破折线

<hr style="background-color:red;">

#### **Unix风格**

| 参数                | 描述                                         |
| ------------------- | -------------------------------------------- |
| -A                  | 显示所有进程                                 |
| -N                  | 显示与指定参数不符的所有进程                 |
| -a                  | 显示除控制进程和无终端进程外的所有进程       |
| -d                  | 显示除控制进程外的所有进程                   |
| -e                  | 显示所有进程                                 |
| -C      *cmdlist*   | 显示包含在*cmdlist*列表中的进程              |
| -G      *grplist*   | 显示组ID在*grplist*列表的进程                |
| -U      *userlist*  | 显示属主的用户ID在*userlist*列表中的进程     |
| -g       *grplit*   | 显示会话或组ID在*grplist*列表中的进程        |
| -p       *pidlist*  | 显示PID在*pidlist*列表中的进程               |
| -s       *sesslist* | 显示会话ID在*sesslist*列表中的进程           |
| -t       *ttylist*  | 显示终端ID在*ttylist*列表中的进程诶          |
| -u      *userlist*  | 显示有效用户ID在*userlist*列表中的进程       |
| -F                  | 显示更多额外输出（相对-f参数而言）           |
| -O      *format*    | 显示默认的输出列以及*format*列表指定的特定列 |
| -M                  | 显示进程的安全信息                           |
| -c                  | 显示进程的额外调度器信息                     |
| -f                  | 显示完整格式的输出                           |
| -j                  | 显示任务信息                                 |
| -l                  | 显示长列表                                   |
| -o        *format*  | 仅显示由*format*指定的列                     |
| -y                  | 不要显示进程标记                             |
| -Z                  | 显示安全标签信息                             |
| -H                  | 用层级格式显示进程（树状，用来显示父进程）   |
| -n       *namelist* | 定义了WCHAN列显示的值                        |
| -w                  | 采用宽输出模式，不限宽度显示                 |
| -L                  | 显示进程中的线程                             |
| -V                  | 显示ps命令的版本号                           |

组合使用

```bash
$ ps -ef
```

<img src="..\Linux命令行与shell脚本大全\img\ps-ef.png" >

* UID：启动这些进程的用户
* PID：进程的进程ID
* PPID：父进程的进程ID
* C：进程生命周期中CPU利用率
* STIME：进程启动时的系统时间
* TTY：进程启动时的终端设备
* TIME：进程需要的累计CPU时间
* CMD：启动的进程名称

采用-l参数，产生长格式输出。

<img src="..\Linux命令行与shell脚本大全\img\ps-l.png">

* F：内核分配给进程的系统标记
* S：进程状态（O代表运行、S代表休眠、R代表可运行和正等待 运行、Z代表僵化（进程已结束但父进程已不存在）、T代表停止。）
* PRI：进程的优先级
* NI：谦让度值用来参与决定优先级
* ADDR：进程的内存地址
* SZ：假如进程被换出，所需交换空间的大致大小
* WCHAN：进程休眠的内核函数的地址

<hr style="background-color:red;border:none">

#### BSD风格

| 参数                | 描述                                                    |
| ------------------- | ------------------------------------------------------- |
| T                   | 显示跟当前终端关联的所有进程                            |
| a                   | 显示跟任意终端关联的所有进程                            |
| g                   | 显示所有的进程，包括进程                                |
| r                   | 仅显示运行中的进程                                      |
| x                   | 显示所有的进程，甚至包括未分配任何终端的进程            |
| U        *userlist* | 显示归*userlist*列表中某用户ID所有的进程                |
| p        *pidlist*  | 显示PID在*pidlist*列表中的进程                          |
| t         *ttylist* | 显示所有关联的终端在*ttylist*列表中的进程               |
| O        *foramt*   | 除了默认输出的列外，还输出由*format*指定的列            |
| X                   | 按过去的Linuxi386寄存器格式显示                         |
| Z                   | 将安全信息添加到输出中                                  |
| j                   | 显示任务信息                                            |
| l                   | 采用长模式                                              |
| o      *foramt*     | 仅显示有*format*指定的列                                |
| s                   | 采用信号格式显示                                        |
| u                   | 采用基于用户的格式显示                                  |
| v                   | 采用虚拟内存格式显示                                    |
| N        *namelist* | 定义在WCHAN列中使用的值                                 |
| O        *order*    | 定义显示信息列的顺序                                    |
| S                   | 将数值信息从子进程加到父进程上，比如CPU和内存的使用情况 |
| c                   | 显示真实的命令名称（用以启动进程的程序名称）            |
| e                   | 显示命令的环境变量                                      |
| f                   | 用分层格式来显示进程，表明哪些进程启动了哪些进程        |
| h                   | 不显示头信息                                            |
| k       *sort*      | 指定用以将输出排序的列                                  |
| n                   | 和WCHAN信息一起显示出来，用数值来表示用户ID和组ID       |
| w                   | 为较宽屏幕显示宽输出                                    |
| H                   | 将线程按进程来显示                                      |
| m                   | 在进程后显示线程                                        |
| L                   | 列出所有格式指定符                                      |
| V                   | 显示ps命令的版本号                                      |

使用BSD参数时，ps命令自动模仿BSD格式。

**如     ps l**

<img src="..\Linux命令行与shell脚本大全\img\psBSD.png">

* VSZ：进程在内存中的大小，以千字节（KB）为单位
* RSS：进程在未换出时占用的物理内存
* STAT：代表当前进程状态的双字符状态码

<hr style="background-color:red;">

#### GNU长参数

| 参数                                 | 描述                                   |
| ------------------------------------ | -------------------------------------- |
| --deselect                           | 显示所有进程，除了命令行中列出的进程   |
| --Group               *grouplist*    | 显示组ID在*grplist*列表中的进程        |
| --User                 *userlist*    | 显示用户ID在*userlist*列表中的进程     |
| --group               *grplist*      | 显示有效组ID在*grplist*列表中的进程    |
| --pid                    *pidlist*   | 显示PID在*pidlist*列表中的进程         |
| --ppid                  *pidlist*    | 显示父PID在*pidlist*列表中的进程       |
| --sid                     *sidlist*  | 显示会话ID在*sidlist*列表中的进程      |
| --tty                      *ttylist* | 显示终端设备号在*ttylist*列表中的进程  |
| --user                  *userlist*   | 显示有效用户ID在*userlist*列表中的进程 |
| --format              *format*       | 仅显示由*format*指定的列               |
| --context                            | 显示额外的安全信息                     |
| --cols                   *n*         | 将屏幕宽度设置为n列                    |
| --columns           *n*              | 将屏幕宽度设置为n列                    |
| --cumulative                         | 包含已经停止的子进程信息               |
| --forset                             | 用层级结构显示出进程和父进程之间的关系 |
| --headers                            | 在每页输出中都显示列的头               |
| --no-headers                         | 不显示列的头                           |
| --lines                 *n*          | 将屏幕高度设置为n列                    |
| --rows                *n*            | 将屏幕高度设置为n排                    |
| --sort                *order*        | 指定将输出按哪列排序                   |
| --width            *n*               | 将屏幕宽度设置为n列                    |
| --help                               | 显示帮助信息                           |
| --info                               | 显示调试信息                           |
| --version                            | 显示ps命令的版本号                     |

### 4.2.top

**top**命令可以实时显示进程信息。

<img src="..\Linux命令行与shell脚本大全\img\top.png">

第一行显示系统的概况：显示当前时间、系统运行时间、登录用户数和系统平均负载。

第二行显示进程概要信息：top命令将进程叫做任务（tasks）。

第三行显示CPU概要信息。

最后一部分显示当前运行中的进程详细列表：

* PID：进程ID
* USER：进程属主的明名字
* PR：进程的优先级
* NI：进程的谦让度值
* VIRT：进程占用的虚拟内存总量
* RES：进程占用的物理内存总量
* SHR：进程和其他进程共享的内存总量
* S：进程状态（D代表可中断的休眠状态、S代表休眠状态、R代表可运行状态、T代表跟踪状态或停止状态、Z代表僵化状态）
* %CPU：进程使用的CPU时间比例
* %MEM：进程使用的内存占可用内存的比例
* TIME+：自进程启动到目前为止的CPU时间总量
* COMMAND：进程所对的命令名称，也就是启动进程的程序名

**按q键退出top**

### 4.3.kill

在linux中，进程之间通过信号来通信。

| 信号 | 名称 | 描述                         |
| ---- | ---- | ---------------------------- |
| 1    | HUP  | 挂起                         |
| 2    | INT  | 中断                         |
| 3    | QUIT | 结束运行                     |
| 9    | KILL | 无条件终止                   |
| 11   | SEGV | 段错误                       |
| 15   | TERM | 尽可能终止                   |
| 17   | STOP | 无条件停止运行，但不终止     |
| 18   | TSTP | 停止或暂停，但继续在后台运行 |
| 19   | CONT | 在STOP或TSTP之后恢复执行     |

**kill**命令可以通过进程ID给进程发信号。前提是必须是进程属主或登录为root用户。

```bash
$ kill 3940
```

-s参数指定其他信号

```bash
$ kill -s HUP 3940 
```

### 4.4.killall

**killall**命令支持通过进程名来结束进程，支持通配符。

```bash
$ killall *java
```

### 4.5.mount

**mount**命令用来挂载媒体。默认情况下，mount命令会输出当前系统上挂载设备列表。

<img src="..\Linux命令行与shell脚本大全\img\mount.png">

**mount**命令提供四部分信息：

* 媒体的设备文件名
* 媒体挂载到虚拟目录的挂载点
* 文件系统类型
* 已挂载媒体的访问状态

手动挂载媒体设备的基本命令（需要root用户身份登录，或sudo命令）

```bash
$ mount -t type device directory
```

**type**参数指定了磁盘被格式化的文件系统类型。

**mount命令的参数：**

| 参数                   | 描述                                                   |
| ---------------------- | ------------------------------------------------------ |
| -a                     | 挂载/etc/fstab文件中指定的所有文件系统                 |
| -f                     | 使mount命令模拟挂载设备，但并不真的挂载                |
| -F                     | 和-a参数一起使用时，会同时挂载所有文件系统             |
| -v                     | 详细模式，将会说明挂载设备的每一步                     |
| -I                     | 不启用任何/sbin/mount.filesystem下的文件系统帮助文件   |
| -l                     | 给ext2、ext3或XFS文件系统自动添加文件系统标签          |
| -n                     | 挂载设备，但不注册到/etc/mtab已挂载设备文件中          |
| -p             *num*   | 进行加密挂载时，从文件描述符*num*中获得密码短语        |
| -s                     | 忽略该文件系统不支持的挂载选项                         |
| -r                     | 将设备挂载为只读的                                     |
| -w                     | 将设备挂载为可读的（默认参数）                         |
| -L             *label* | 将设备按指定的*label*挂载                              |
| -U            *uuid*   | 将设备按指定的*uuid*挂载                               |
| -O                     | 和-a参数一起使用，限制命令只作用到特定的一组文件系统上 |
| -o                     | 给文件系统添加特定的选项                               |

-o参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。

* ro：以只读形式挂载
* rw：以读写形式挂载
* user：允许普通用户挂载文件系统
* check=none：挂载文件系统时不进行完整性校验
* loop：挂载一个文件

### 4.6.umount

卸载设备的命令时**umount**。

> 命令格式：
>
> **umount    [directory | device]**

**umount**命令支持通过设备文件或是挂载点来指定要卸载的设备。

### 4.7.df

**df**命令可以查看所有已挂载磁盘到的使用情况。

<img src="..\Linux命令行与shell脚本大全\img\df.png">

输出字段含义：

* 设备的设备文件位置
* 能容纳多少个1024字节大小的块
* 已用了多少个1024字节大小的块
* 还有多少个1024字节的块可以使用
* 已用空间所占的比例
* 设备挂载到了哪个挂载点上

```bash
$ df -h    # 用M代表兆字节，G代表吉字节，更加易读
```

### 4.8.du

**du**命令可以显示某个特定目录（默认是当前目录）的磁盘使用情况。

可以判断目录下是不是有超大文件。

```bash
$ du -ah
```

<img src="..\Linux命令行与shell脚本大全\img\du-ah.png">

### 4.9.sort

**sort**排序数据。**sort**命令是对数据进行排序的，默认语言的排序规则对文本文件中的数据行排序。

按月排序，**sort**能识别三字符的月份名。

```bash
$ sort -M file
```

### 4.10.grep

搜索文件。

>  命令格式：
>
>  **grep    [option]     pattern     [file]**

**grep**命令会在输入或指定的文件中查找包含配备指定模式的字符的行。支持正则表达式。

查看file中的包含s字符的行。

<img src="..\Linux命令行与shell脚本大全\img\grep.png">

反向搜索（输出不匹配该模式的行），加参数   -v

```bash
$ grep -v s file
```

显示匹配行所在行号，加参数   -n

```bash
$ grep -n s file  
```

输出有多少行含有匹配模式，加参数   -c

```bash
$ grep -c s file
```

### 4.11.压缩数据

Linux文件压缩工具

| 工具     | 文件扩展名 | 描述                                              |
| -------- | ---------- | ------------------------------------------------- |
| bzip2    | .bz2       | 采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码 |
| compress | .Z         | 最初的Unix文件压缩工具，已经快没人用了            |
| gzip     | .gz        | GNU压缩工具，用Lempel-Ziv编码                     |
| zip      | .zip       | Windows上PKZIP工具的Unix实现                      |

#### 4.11.1.gzip

**gzip**用来压缩文件

```bash
$ gzip file
```

#### 4.11.2.gunzip

**gunzip**用来解压文件

```bash
$ gunzip file.gz
```

#### 4.11.3.gzcat

**gzcat**用来查看压缩过的文本文件的内容。

```bash
$ gzcat file.gz
```

### 4.12.tar

**tar**命令是Unix和Linux上最广泛的归档工具。

> 命令格式：
>
> **tar   function  [option]   object1  object2 ...**

function参数定义了tar命令应该做什么。

**tar**命令的功能：

| 功能 | 长命令        | 描述                                                         |
| ---- | ------------- | ------------------------------------------------------------ |
| -A   | --concatenate | 将一个已有tar归档文件追加到另一个已有的tar归档文件           |
| -c   | --create      | 创建一个新的tar归档文件                                      |
| -d   | --diff        | 检查归档文件和文件系统的不同之处                             |
|      | --delete      | 从已有的tar归档文件中删除                                    |
| -r   | --append      | 追加文件到已有的tar归档文件末尾                              |
| -t   | --list        | 列出已有tar归档文件的内容                                    |
| -u   | --update      | 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 |
| -x   | --extract     | 从已有的tar归档文件中提取文件                                |

<hr>
**tar**命令选项：

| 选项              | 描述                                |
| ----------------- | ----------------------------------- |
| -C        *dir*   | 切换到指定目录                      |
| -f         *file* | 输出结果到文件或设备*file*          |
| -j                | 将输出重定向给*bzip2*命令来压缩内容 |
| -p                | 保留所有文件权限                    |
| -v                | 在处理文件时显示文件                |
| -z                | 将输出重定向给*gzip*命令来解压内容  |

<hr>

解压.tgz文件

```bash
$ tar -zxvf fileName.tgz
```

## 5.理解shell

### 5.1.shell的父子关系

输入bash、生成子shell。生成子shell进程时只有部分父进程的环境变量被复制到了子shell中。

**ps --forest**命令展示了shell间的嵌套关系。

<img src="..\Linux命令行与shell脚本大全\img\ps--forest.png">

bash的参数：

| 参数          | 描述                                        |
| ------------- | ------------------------------------------- |
| -c     string | 从string中读取命令并进行处理                |
| -i            | 启动一个能够接受用户输入的交互shell         |
| -l            | 以登录shell的形式启动                       |
| -r            | 启动一个受限shell，用户会被限制在默认目录中 |
| -s            | 从标准输入中读取命令                        |

退出命令**exit**

### 5.2.进程列表

多个命令中间加分号；并用（）括起来。

```bash
$ (clear;pwd;ls;cd)
```

### 5.3.sleep

**sleep**命令接受一个参数，该参数是进程等待的秒数。

```bash
$ sleep  10
```

### 5.4.&

&符用于将进程挂到后台进行。

```bash
$ sleep 10&
```

### 5.5.jobs

**jobs**命令用来显示后台作业信息。它显示了作业号、作业状态以及对应命令。

```bash
$ jobs
$ jobs -l
```

***在CLI中运用子shell的创造性方法之一就是将进程列表置于后台模式。***

### 5.6.协程

协程可以同时做两件事。

1. 在后台生成一个子shell
2. 在子shell中执行命令

### 5.7.coproc

**coproc**命令开启协程

```bash
$ coproc my_job {sleep 10; }
```

### 5.8.外部命令

外部命令，也被称为文件系统命令，是存在于bash shell之外的命令。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。外部命令执行时，会创建一个子进程。

ps就是一个外部命令。

### 5.9.内建命令

内建命令不需要子进程来执行。内建命令的执行速度要更快，效率也更高。

命令有多种实现，例如**echo**和**pwd**既有内建命令也有外部命令。

### 5.10.type

**type -a** 命令用来查看命令的不同实现。

```bash
$ type -a echo
```

<img src="..\Linux命令行与shell脚本大全\img\type-a.png">

### 5.11.which

**which**命令只显示出了外部命令文件。

```bash
$ which -a echo
```

<img src="..\Linux命令行与shell脚本大全\img\which-a.png">

### 5.12.history

**history**会输出已经执行的历史命令，通常会保存最近1000条命令。

！！会执行上一条命令。

！加数字执行指定历史命令。

### 5.13.alias

**alias**用来创建命令的别名。

```bash
$ alias li="ls -li"
```

## 6.Linux环境变量

### 6.1.什么是环境变量

bash shell用一个叫作环境变量（environment variable）的特性来存储有关shell会话和工作环境的信息。

在bash shell中，环境变量分为两类：

* 全局变量
* 局部变量

**全局环境变量对于shell会话和所有生成的子shell都是可见的。**

**局部变量则只对创建它们的shell可见。**

### 6.2.env

查看全局变量，可以用env或printenv。

```bash
$ env
$ printenv
```

<img src="..\Linux命令行与shell脚本大全\img\env.png">

### 6.3.printenv

显示个别环境变量

```bash
$ printenv HOME
```

<img src="..\Linux命令行与shell脚本大全\img\printenvHOME.png">

使用echo命令打印环境变量的值，环境变量的值用$符号引用。

```bash
$ echo $HOME
```

<img src="..\Linux命令行与shell脚本大全\img\echoHOME.png">

环境变量前加$可以将变量作为参数作为命令行参数。

<img src="..\Linux命令行与shell脚本大全\img\lsHOME.png">

**全局变量可作用于所有的子shell。**

### 6.4.set

**局部变量只能在定义它们的进程中可见。**

在Linux系统并没有一个只显示局部变量的命令。

**set**命令会显示为某个特定进程设置的所有环境变量，包括局部变量、环境变量以及用户定义变量。

```bash
$ set | head -10
```

<img src="..\Linux命令行与shell脚本大全\img\set.png">

### 6.5.用户定义变量

#### 6.5.1.用户定义局部变量

>  格式：
>
> $变量名=变量值

变量值可以是数字或字符串，当字符串之间有空格时必须加单引号。

**变量名、等号和值之间没有空格。**

子shell中设置的变量在父shell中不可用。退出子进程后自定义环境变量失效。

#### 6.5.2.用户定义全局变量

创建全局环境变量的方法

1. 先创建一个局部环境变量
2. 使用expotr命令导出

```bash
$ a="Hello World"
$ expotr a
```

修改子shell中全局变量并不会影响到父shell中该变量的值。

子shell无法使用**export**命令改变父shell中全局变量的值。

### 6.6.删除环境变量

```bash
$ unset [变量名]
```

**子进程中删除一个全局环境变量，这只对子进程有效。该全局环境变量在父进程中仍然有效。**

### 6.7.默认环境变量

| 变量                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| CDPATH                | 冒号分隔的目录列表，作为cd命令的搜索路径                     |
| HOME                  | 当前用户的出目录                                             |
| IFS                   | shell用来将文本字符串分隔成字段的一系列字符                  |
| MAIL                  | 当前用户收件箱的文件名                                       |
| MAILPATH              | 冒号分隔的当前用户收件箱的文件名列表                         |
| OPTARG                | getopts命令处理的最后一个选项参数值                          |
| OPTIND                | getopts命令处理的最后一个选项参数值的索引号                  |
| PATH                  | shell命令查找命令的目录列表，由冒号分隔                      |
| PS1                   | shell命令行界面的主提示符                                    |
| PS2                   | shell命令行界面的次提示符                                    |
| BASH                  | 当前shell实例的全路径名                                      |
| BASH_ALIASES          | 含有当前已设置别名的关联数组                                 |
| BASH_ARGC             | 含有传入子函数或shell脚本的参数总数的数组变量                |
| BASH_ARCV             | 含有传入子函数或shell脚本的参数的数组变量                    |
| BASH_CMDS             | 关联数组，包含shell执行过的命令的所在位置                    |
| BASH_COMMAND          | shell正在执行的命令或马上就执行的命令                        |
| BASH_ENV              | 设置了的话，每个bash脚本会在运行前尝试运行该变量定义的启动文件 |
| BASH_EXECUTION_STRING | 使用bash -c选项传递过来的命令                                |
| BASH_LINENO           | 含有当前执行的shell函数所在源文件名的数组变量                |
| BASH_REMATCH          | 只读数组，在使用正则表达式的比较运算父=~进行肯定匹配时，包含了匹配到的模式和子模式 |
| BASH_SOURCE           | 含有当前正在执行的shell函数所在源文件名的数组变量            |
| BASH_SUBSHELL         | 当前子shell环境的嵌套级别（初始值是0）                       |
| BASH_VERSINFO         | 含有当前运行的bash shell的主版本号                           |
|                       |                                                              |
|                       |                                                              |
|                       |                                                              |
|                       |                                                              |
|                       |                                                              |
|                       |                                                              |
|                       |                                                              |
|                       |                                                              |

### 6.8.设置PATH环境变量

PATH环境变量定义了用于进行命令和程序查找的目录。

添加PATH值：

```bash
$ PATH=$PATH:/home/turing/Script
```

这种对PATH变量的修改只能持续到退出或重启系统。

### 6.9.系统环境变量

启动shell的三种方式：

* 登录时作为默认登录的shell
* 作为非登录shell的交互式shell
* 作为运行脚本的非交互式shelll

#### 6.9.1.登录shell

登录shell会从5个不同的启动文件里读取命令：

* /etc/profile
* $HOME/.bash_profile
* $HOME/.bashrc
* $HOME/.bash_login
* $HOME/.profile

1. /etc/profile文件

/etc/profile文件是系统默认的bash shell的主启动文件。系统上每个用户登录时都会执行这个启动文件。

2. $HOME目录下的启动文件

同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环境变量。大多数Linux发行版只用这四个启动文件中的一到两个。

#### 6.9.2.交互式shell

如果bash shell不是登录系统时启动的，那这个shell叫做交互式shell。它就不会访问/etc/profile文件，只会检查用户的HOME中的.bashrc文件。

.bashrc文件有两个作用：

* 查看/etc目录下通用的bashrc文件
* 为用户提供一个定制自己的命令别名和私有脚本函数的地方

#### 6.9.3.非交互式shell

#### 6.9.4.环境变量持久化

最好在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有的新的或修改过的全局变量设置放在这个文件中。

### 6.10.数组变量

环境变量可以作为数组使用。

给某个环境变量设置多个值，把值放在括号里，值与值之间用空格分隔。

```bash
$ mytest=(one two three four five)
```

使用索引访问（索引值从0开始）

```bash
$ echo ${mytest[2]}
```

使用整个数组元素

```bash
$ echo ${mytest[*]}
```

改变某个索引位置的值

```bash
$ mytest[2]=seven
```

删除数组中的某个值

```bash
$ unset mytest[2]
$ unset mytest     # 删除整个数组
```

## 7.Linux文件权限

### 7.1.Linux的安全性

Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。

用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。

Linux系统使用一个专门的文件（/etc/passwd）来将用户的登录名匹配到对应的UID值。

<img src="..\Linux命令行与shell脚本大全\img\etc-passwd.png">

root用户账户是Linux系统的管理员，固定分配给它的UID是0。Linux系统会为各种各样的功能创建不同的用户账户，这些账户不是真正的用户，叫系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。

Linux为系统账户预留了500以下的UID值。

> /etc/passwd文件的字段包含：
>
> * 登录用户名
> * 用户密码
> * 用户账户的UID（数字形式）
> * 用户账户的组ID（GID）（数字形式）
> * 用户账户的文本描述（称为备注字段）
> * 用户HOME目录的位置
> * 用户默认的shell

/etc/passwd文件中的密码字段都被设置成了x。

**绝大数Linux系统都将用户密码保存在（/etc/shadow）。只有root用户可以访问。**

/etc/shadow文件为系统上的每个用户账户都保存了一条记录。

<img src="..\Linux命令行与shell脚本大全\img\etc-shadow.png">

> /etc/shadow文件的每个记录都有9个字段：
>
> * 与/etc/passwd文件中的登录名字段对应的登录名
> * 加密后的密码
> * 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）
> * 多少天后才能更改密码
> * 多少天后必须更改密码
> * 密码过期前提前多少天提醒用户更改密码
> * 密码过期后多少天禁用用户账户
> * 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）
> * 预留字段给将来使用

### 7.2.添加用户

添加用户的主要工具是**useradd**。**useradd**命令使用系统默认值以及命令行参数来设置用户账户。系统默认值被设置在/etc/default/useradd文件中。可以使用-D选项的**useradd**命令查看所用Linux中的默认值。

<img src="..\Linux命令行与shell脚本大全\img\useradd-D.png">

>  默认值的内容：
>
> 1. 新用户会被添加到GID为100的公共组
> 2. 新用户的HOME目录会位于/home/用户名
> 3. 新用户帐号密码在过期后不会被禁用
> 4. 新用户账户未被设置过期日期
> 5. 新用户的默认shell为/sh
> 6. 系统会将/etc/skel目录下的内容复制到用户的HOME目录下
>
> <img src="..\Linux命令行与shell脚本大全\img\etc-skel.png">
>
> 7. 系统不会为用户在mail目录下创建一个用于接受邮件的文件

**useradd**命令不会创建HOME目录，加上选项**-m**会使其创建HOME目录。

| 参数                            | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| -c             *comment*        | 给新用户添加备注                                             |
| -d             *home_dir*       | 为主目录指定一个名字（不想用登录名作为主目录名）             |
| -e             *expire_date*    | 用YYYY-MM-DD格式指定一个账户过期的日期                       |
| -f              *inactive_days* | 指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立刻禁用，-1表示禁用这个功能 |
| -g              *initial_group* | 指定用户登录组的GID或组名                                    |
| -G             *group    ...*   | 指定用户除登录组之外所属的一个或多个附加组                   |
| -k                              | 必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录  |
| -m                              | 创建用户的HOME目录                                           |
| -M                              | 不创建用户的HOME目录（默认）                                 |
| -n                              | 创建一个与用户登录名相同的组名                               |
| -r                              | 创建系统账户                                                 |
| -p            *passwd*          | 为用户指定密码                                               |
| -s             *shell*          | 指定默认的登录shell                                          |
| -u            *uid*             | 为账户指定唯一的UID                                          |

使用-D修改系统默认的新用户设置。

| 参数                        | 描述                                         |
| --------------------------- | -------------------------------------------- |
| -b         *default_home*   | 更改默认的创建用户HOME目录的位置             |
| -e        *expiration_date* | 更改默认的新账户的过期日期                   |
| -f         *inactive*       | 更改默认的新账户从密码过期到账户被禁用的天数 |
| -g         *group*          | 更改默认的组名称或GID                        |
| -s         *shell*          | 更改默认的登录shell                          |

```bash
$ useradd -D -s /bin/tsch
```

### 7.3.删除用户

**userdel**命令用来删除用户，默认情况下，**userdel**只会删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件。

加上-r参数**userdel**会删除用户的HOME目录以及邮件目录。

```bash
$ userdel -r test
```

### 7.4.修改账户

>  修改工具
>
> 1. usermod      修改用户账户的字段，还可以指定组以及附加组的所属关系
> 2. passwd         修改已有用户的密码
> 3. chpasswd     从文件中读取登录密码对，并更新密码
> 4. chage            修改密码的过期日期
> 5. chfn               修改用户账户的备注信息
> 6. chsh              修改用户账户的默认登录shell

#### 7.4.1.usermod

**usermod**是修改工具中功能最强大的一个，它可以修改/etc/passwd文件中大部分字段。

| 参数 | 描述                     |
| ---- | ------------------------ |
| -c   | 修改备注字段             |
| -e   | 修改过期日期             |
| -g   | 修改默认的登录组         |
| -l   | 修改用户账户的登录名     |
| -L   | 锁定账户，使用户无法登录 |
| -p   | 修改账户密码             |
| -U   | 解除账户，使用户可以登录 |

#### 7.4.2.passwd和chpasswd

**passwd**命令只会修改自己的密码，系统上的任何用户都能修改自己的密码，只有root用户才有权限修改别人的密码。-e参数强制用户下次登录时修改密码。

大量用户修改密码，可以使用chpasswd命令，它可以从标准输入自动读取登录名和密码对（由分号分隔）列表，给密码加密，然后为用户账户设置。

```bash
$ chpasswd < users.txt     # users.txt  (userID:passwd)
```

#### 7.4.3.chsh、chfn和chage

**chsh**命令用来快速修改默认用户的shell，必须用shell的全路径作为参数。

**chfn**命令会将用于Unix的finger命令的信息存进备注字段。

**finger**命令可以非常方便地查看Linux系统上的用户信息。

**chage**命令用来帮助管理账户的有效期。

| 参数 | 描述                               |
| ---- | ---------------------------------- |
| -d   | 设置上次修改密码到现在的天数       |
| -E   | 设置密码过期的日期                 |
| -I   | 设置密码过期到锁定账户的天数       |
| -m   | 设置修改密码之间最少要多少天       |
| -w   | 设置密码过期前多久开始出现提醒信息 |

>  chage命令的日期格式：
>
> * YYYY-MM-DD
> * 从1970年1月1日起到该日期的天数

### 7.5.Linux组

Linux组概念用来解决共享资源以及安全性的问题。

每个组都有唯一的GID。除了GID，每个组还有唯一的组名。

#### 7.5.1./etc/group

/etc/group文件包含系统上用到的每个组的信息。

<img src="..\Linux命令行与shell脚本大全\img\etc-group.png">

> /etc/group文件有4个字段：
>
> * 组名
> * 组密码
> * GID
> * 属于该组的用户列表

#### 7.5.2.创建新组

**groupadd**命令用在来系统上创建新组。

使用**usermod**将用户分配到创建的组内。

#### 7.5.3.修改组

**groupmod**命令可以修改已有组的GID（-g）或组名（-n）。

### 7.6.文件权限

#### 7.6.1.文件权限符

<img src="..\Linux命令行与shell脚本大全\img\ls-l.png">

<img src="..\Linux命令行与shell脚本大全\img\文件权限.png">

> 第一个字段就是描述文件和目录权限的编码。（-）
>
> * -代表文件
> * d代表目录
> * l代表链接
> * c代表字符型设备
> * b代表块设备
> * n代表网路设备
>
> 之后有3组三字符编码，每一组定义了3中访问权限：
>
> * r代表对象是可读的
> * w代表对象是可写的
> * x代表对象是可执行的
>
> 若没有某种权限用-代替，3组权限分别代表3个安全级别：
>
> * 对象的属主
> * 对象的属组
> * 系统的其他用户

#### 7.6.2.默认文件权限

**umask**命令来设置所创建文件和目录的默认权限。

**umask**命令可以显示和设置默认权限。

<img src="..\Linux命令行与shell脚本大全\img\umask.png">

> 四位数字，第一位代表一项特别的安全特性，叫**粘着位**。后面的3位表示文件或目录对应的**umask**八进制值。
>
> 八进制模式的安全设置先获取这3个rwx权限的值，然后将其转换成3位二进制值，用一个八进制值来表示。在这个二进制表示中，每个位置代表一个二进制位。
>
> | 权限 | 二进制值 | 八进制值 |       描述       |
> | :--: | :------: | :------: | :--------------: |
> | ---  |   000    |    0     |   没有任何权限   |
> | --x  |   001    |    1     |   只有执行权限   |
> | -w-  |   010    |    2     |   只有写入权限   |
> | -wx  |   011    |    3     | 有写入和执行权限 |
> | r--  |   100    |    4     |   只有读取权限   |
> | r-x  |   101    |    5     | 有读取和执行权限 |
> | rw-  |   110    |    6     | 有读取和写入权限 |
> | rwx  |   111    |    7     |    有全部权限    |

umask值只是个掩码。

文件的全权限是666，上面umask的默认值取后3位，即002。用666减去002得到664，根据上表可知默认创建的文件权限为-rw-rw-r--。

<img src="..\Linux命令行与shell脚本大全\img\默认创建文件权限.png">

目录的全权限为777。与上面的计算方式一样。可知目录权限为drwxrwxr-x。

<img src="..\Linux命令行与shell脚本大全\img\默认创建目录权限.png">

#### 7.6.3.修改默认创建权限

```bash
$ umask 026   # umask后跟一个三位八进制数
```

### 7.7.改变安全性设置

#### 7.7.1.改变权限

**chmod**命令用来改变文件和目录的安全性设置。

> 命令格式：
>
> chmod   *options*   *mode*    file

mode参数可以使用八进制模式或符号模式进入安全性设置。

```bash
$ chmod 666 file
```

符号模式

> 格式：
>
> [ugoa...]   [[+-=] [rwxXstugo...]] 

第一组字符定义了权限作用的对象

> * u代表用户
> * g代表组
> * o代表其他
> * a代表上述所有

第二个的符号代表增加权限（+），减少权限（-），将权限设置成后面的值（=）。

第三个字符代表作用在文件上的权限。

> * X：如果对象是目录或者它已有执行权限，赋予执行权限
> * s：运行时重新设置UID或GID
> * t：保留文件或目录
> * u：设置属主权限
> * g：设置组权限
> * o：设置其他用户权限

```bash
$ chmod u+x file
```

#### 7.7.2.改变所属关系

**chown** 命令用来改变文件的属主。

> chown   *options*   *owner[.group]   file*
>
> ```bash
> $ chown jason file
> ```

-R选项配合通配符可以递归地改变子目录和文件的所属关系。-h选项可以改变该文件的所有符号链接文件的所属关系。

**chgrp**命令用来改变文件的默认属主。

### 7.8.共享文件

Linux上共享文件的方式是创建组。

Linux为每个文件和目录存储了3个额外的信息位。

* 设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。
* 设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。
* 粘着位：进程结束后文件还驻留（粘着）在内存中。

## 8.管理文件系统

### 8.1.

## 9.安装软件程序

TODO

## 10.使用编辑器

TODO

# 第二部分    shell脚本编程基础

## 11.构建基本脚本

### 11.1.使用多个命令

命令之间用分号隔开。

```bash
$ date ; who
```

### 11.2.shell脚本

