# 第一部分  Linux命令行

## 1. 初识Linux shell

### 1.1. Linux划分

* Linux内核
* GNU工具
* 图形化桌面环境
* 应用软件

<img src="..\Linux命令行与shell脚本大全\img\Linux系统.png">

### 1.2. 内核的功能

* 系统内存管理
* 软件程序管理
* 硬件设备管理
* 文件系统管理

#### 1.2.1. 系统内存管理

内核使用硬盘上的存储空间实现虚拟内存，这块区域叫做交换空间。内核不断地在交换空间和实际物理空间之间反复交换虚拟内存中的内容。

<img src="..\Linux命令行与shell脚本大全\img\Linux内存映射.png">

#### 1.2.2. 软件程序管理

Linux发行版使用一个表来管理系统开机时要自动启动的进程。这个表位于专门文件/etc/inittab中。

Linux系统有5个运行级。

运行级为1时，只能启动基本的系统进程以及一个控制台终端进程。称为单用户模式。标准的启动运行级是3级，在这个运行级上大多数应用软件都会启动。

运行级5级，允许用户用图形化窗口登录系统。

#### 1.2.3. 硬件设备管理

Linux内核中两种方法用于插入设备驱动代码：

* 编译进内核的设备驱动代码
* 可插入内核的设备驱动模块

Linux系统将硬件设备当成特殊文件，称为设备文件。设备文件有三种分类：

* 字符型设备文件
* 块设备文件
* 网络设备文件

#### 1.2.4. 文件系统管理

Linux内核采用虚拟文件系统作为和每个文件系统的接口。

| 文件系统 | 描述                                              |
| -------- | ------------------------------------------------- |
| ext      | Linux扩展文件系统，最早的Linux文件系统            |
| ext2     | 第二扩展文件系统                                  |
| ext3     | 第三扩展文件系统，支持日志功能                    |
| ext4     | 第四扩展文件系统，支持高级日志功能                |
| hpfs     | OS/2高性能文件系统                                |
| jfs      | IBM日志文件系统                                   |
| iso9660  | ISO  9660文件系统（CD-ROM）                       |
| minix    | MINIX文件系统                                     |
| msdos    | 微软的FAT16                                       |
| ncp      | Netware文件系统                                   |
| nfs      | 网络文件系统                                      |
| ntfs     | 支持Microsoft NT文件系统                          |
| proc     | 访问系统信息                                      |
| ReiserFS | 高级Linux文件系统，能提供更好的性能和硬盘恢复功能 |
| smb      | 支持网络访问的Samba SMB文件系统                   |
| sysv     | 较早期的Unix文件系统                              |
| ufs      | BSD文件系统                                       |
| umsdos   | 建立在msdos上的类Unix文件系统                     |
| vfat     | Windows 95文件系统（FAT32）                       |
| XFS      | 高性能64位日志文件系统                            |

### 1.3. GNU工具

#### 1.3.1. 核心GNU工具

* 用于处理文件的工具
* 用于操作文本的工具
* 用于管理进程的工具

#### 1.3.2. shell

GUN为Linux开发了bash shell。

其他一些shell

| shell |                                                              |
| ----- | ------------------------------------------------------------ |
| ash   | 运行在内核受限环境中简单的轻量级shell，与bash shell完全兼容  |
| korn  | 与Bourne shell兼容的编程shell，支持关联数组和浮点运算        |
| tcsh  | 将c语言中的一些元素引入到shell脚本中的shell                  |
| zsh   | 结合了bash、tcsh和kron的特性，同时提供高级编程特性、共享历史文件和主题化提示符的高级shell |

### 1.4. Linux桌面环境

1. X Windiws
2. KDE
3. GNOME
4. Unity

### 1.5. Linux发行版

核心发行版

1. Slackware      最早的Linux发行版之一
2. Red Hat          用于Internet服务器的商业发行版
3. Fedora            从Red Hat分离出的家用发行版
4. Gentoo           为高级Linux用户设计的发行版，仅包含Linux源代码
5. openSUSE      用于商业和家用的发行版
6. Debain 

## 2. 走进shell

### 2.1. CLI

在图形化桌面出现以前，与Unix系统进行交互的唯一方式就是借助有shell所提供的文本命令行界面（Command line interface，CLI）。

图像化终端

终端仿真包

通过登录Linux控制台，进入CLI。

```BASH
$ setterm -inversescreen on  # 将终端的背景设置为白色、文本设置为黑色
$ setterm -inversescreen off # 关闭
```

setterm 选项

| 选项           | 参数                                                  | 描述                                           |
| -------------- | ----------------------------------------------------- | ---------------------------------------------- |
| -background    | black、red、green、yellow、blue、magenta、cyan、white | 将终端的背景色改为指定颜色                     |
| -foreground    | black、red、green、yellow、blue、magenta、cyan、white | 将终端的前景色改为指定颜色                     |
| -inversescreen | off、on                                               | 交换背景色和前景色                             |
| -reset         | 无                                                    | 将终端外观恢复成默认设置并清屏                 |
| -store         | 无                                                    | 将终端当前的前景色和背景色设置成-reset选项的值 |

### 2.2. 图形化终端仿真访问CLI

* GNOME Terminal
* Konsole Terminal
* xterm

## 3. 基本的bash shell命令

### 3.1. 启动shell

/etc/passwd文件包含了所有系统用户账户列表以及每个用户的基本配置信息。每个条目包含7个字段字段之间用冒号隔开。

```bsah
turing:x:1000:1000:alan turing:/home/turing:/bin/bash
```

最后一个字段指定了该用户的默认shell，用户登录成功后默认启动。

### 3.2. bash手册

man命令用于访问Linux系统上的手册页面。手册页由分页程序（pager）来显示。

如查看ls命令:

```bash
$ man ls
```

**手册节名**

| 节            | 描述                       |
| ------------- | -------------------------- |
| Name          | 显示命令名和一段简短的描述 |
| Synopsis      | 命令的语法                 |
| Configuration | 命令的配置信息             |
| Description   | 命令的一般性描述           |
| Options       | 命令的选项描述             |
| Exit Status   | 命令的退出状态指示         |
| Return Value  | 命令的返回值               |
| Errors        | 命令的错误消息             |
| Environment   | 描述所使用的环境变量       |
| Files         | 命令使用到的文件           |
| Versions      | 命令的版本信息             |
| Conforming To | 命令所遵守的标准           |
| Notes         | 其他有帮助的资料           |
| Bugs          | 提交bug的途径              |
| Example       | 展示命令的用法             |
| Authors       | 命令的开发人员信息         |
| Copyright     | 命令源代码的版本状况       |
| See Also      | 与该命令相似的其他命令     |

查找命令

```bash
$ man -k "关键字"

$ man -k treminal   # 与系统相关的命令
```

### 3.3. Linux文件系统

Linux将文件存储在单个目录结构中，这个目录被称为虚拟目录（virtual directory）。

Linux会在根驱动器上创建一些特别的目录，称为挂载点（mount point）。

<img src="..\Frank_Linux\img\Linux目录.png"/> 

常见的目录名均基于文件系统层级标准（Filesystem Hierarchy Standard，FHS）。<a href="http://www.pathname.com/fhs">官方主页</a>

### 3.4. cd

**cd**命令将shell会话切换到另一个目录。

**cd**命令支持两种参数

* 相对路径
* 绝对路径
* . 单点符表示当前目录
* ..  双点符表示当前目录的父目录

```bash
$ cd /etc

$ cd ..     # 回到上一级目录

$ cd ../..  # 回到上上一级目录

$ cd        # 回到用户目录，root用户为/root
```

### 3.5. pwd

打印当前位置的目录的绝对路径

```bash
$ pwd
```

### 3.6. ls

#### 3.6.1. 基本使用

查看当前目录下的文件和文件夹

ls命令输出的列表按字母排序（按列排序）。

```bash
$ ls
```

-F 参数用于区分文件和文件夹

```bash
$ ls -F
```

-a 参数用于显示隐藏文件

```bash
$ ls -a
```

-R 参数会递归的显示所有文件和文件夹

```bash
$ ls -R
```

合并使用

```bash
$ ls -FR
```

#### 3.6.2. 显示长列表

-l 参数会显示文件信息，并产生长列表格式输出。

```bash
$ ls -l
```

<img src="..\Linux命令行与shell脚本大全\img\文件信息.png" />

**字段依次表示为：**

* **文件的类型，目录(d)、文件(-)、字符型文件(c)、块设备(b)、链接文件(l)；**
* **文件的权限，三位一组，分别为创建的用户、用户所属的组、其他用户**
* **文件的硬链接总数**
* **文件属主的用户名**
* **文件组的组名**
* **文件的大小（以字节为单位）**
* **文件上次修改的事件**
* **文件名或目录名**

#### 3.6.3. 过滤文件

* **？问号代表一个字符**
* ***星号代表0个或多个字符**
* **[a..] 匹配方括号中的单个字符**
* **[a-z] 匹配方括号中的单个字符**
* **[!a]将不需要的字符排除**

**--time=atime**显示文件的访问时间

```bash
$ ls -l --time=atime Test.java
```

### 3.7. touch

**touch**命令用于创建空文件

```bash
$ touch Test.java
```

```bash
$ touch 1.java 2.c 3.cpp       # 一次创建多个空文件
```

**touch**命令可以改变文件的修改事时间。此操作并不改变文件内容。

**touch -a** 改变文件的访问时间。

### 3.8. cp

复制文件。

基本用法，cp命令需要两个参数——源对象和目标对象

如果源对象和目标对象都是文件，则源文件覆盖目标文夹

```bash
$ cp -i 1.java ../test/          # 复制文件到test目录下
```

-i  参数询问你是否执行此操作。

-R   可以用来复制文件夹及包含的所有文件

```bash
$ cp -R project test/           # project是一个文件夹
```

cp命令可以使用通配符

```bash
$ cp *.java  src/              # 复制所有java文件到src目录下
```

***对于文件名复杂的文件，使用Tab键自动补全文件名称***

### 3.9. 链接文件

>  两种类型的文件链接：
>
> * 符号链接
> * 硬链接

要为一个文件创建符号链接，原始文件必须事先存在。链接文件是独立的文件。符号链接的名字位于ln命令的第二个参数位置上。

```bash
$ ln -s file  ln_file
```

创建硬链接。硬链接会创建独立的虚拟文件，其中包含原始文件的信息及位置，它们从根本上而言是同一个文件。引用硬链接等同引用了源文件。

```bash
$ ln file  ln_file
```

### 3.10. mv

**mv**命令可以重命名文件

```bash
$ mv lod_fileName  new_fileName
```

mv命令移动文件位置

```bash
$ mv file  ~/Document/
```

mv命令移动文件并重命名

```bash
$ mv fileName  ~/Document/fileName
```

mv命令移动整个目录及其内容

 ```bash
 $ mv dir ~/Document/
 ```

### 3.11. rm

删除文件或文件夹。-i参数提示是否真要删除文件。（好习惯）

```bash
$ rm -i file
```

-f 参数越过提示信息直接删除

```bash
$ rm -f file
```

-r 删除目录

```bash
$ rm -r dir
```

删除目录并越过提示

```bash
$ rm -rf dir
```

**rm**命令支持通配符

### 3.12. mkdir

创建一个空目录

```BASH
$ mkdir dirName
```

创建多级目录

```bash
$ mkdir -p src/java/
```

### 3.13. rmdir

**rmdir**只能删除空目录。

```bash
$ rmdir project
```

### 3.14. file

**file**命令可以查看文件的类型和编码。

```bash
$ file ln_file
```

### 3.15. cat

**cat**命令展示文件的文本内容。

-n参数会对每一行加上行号。

-b参数只对有文本信息的行加上行号。

-T参数用^I字符代替文本中的所有制表符。

### 3.16. more

**more**命令会显示文本的内容，但会在显示每页数据后停下来。

```bash
$ more file
```

### 3.17. less

**less**是**more**的升级版，实现文本前后翻页和支持搜索文本。

```bash
$ less file
```

### 3.18. tail

**tail**命令会显示文件最后几行的内容，默认为10行。-n参数指定行数。

```bash
$ tail -n 4 logFile
```

或

```bash
$ tail -4 logFile
```

### 3.19. head

**head**命令会显示文件前几行的内容，默认为10行。-n参数指定行数。

```bash
$ head -n 4 logFile
```

或

```bash
$ head -4 logFile
```

## 4. 更多的bash shell命令

### 4.1. ps

**ps**命令可以输出系统上的所有进程的许多信息。

```bash
$ ps
```

<img src="..\Linux命令行与shell脚本大全\img\ps进程信息.png">

上例输出了进程的ID（Process ID，PID）、它们运行在哪个终端（TTY）以及进程以用的CPU时间。

<hr />

>  ps命令支持3种不同类型的命令行参数：
>
>  * Unix风格的参数，前面加单破折线
>  * BSD风格的参数，前面不加破折线
>  * GNU风格的长参数，前面加双破折线

<hr style="background-color:red;">

#### **Unix风格**

| 参数                | 描述                                         |
| ------------------- | -------------------------------------------- |
| -A                  | 显示所有进程                                 |
| -N                  | 显示与指定参数不符的所有进程                 |
| -a                  | 显示除控制进程和无终端进程外的所有进程       |
| -d                  | 显示除控制进程外的所有进程                   |
| -e                  | 显示所有进程                                 |
| -C      *cmdlist*   | 显示包含在*cmdlist*列表中的进程              |
| -G      *grplist*   | 显示组ID在*grplist*列表的进程                |
| -U      *userlist*  | 显示属主的用户ID在*userlist*列表中的进程     |
| -g       *grplit*   | 显示会话或组ID在*grplist*列表中的进程        |
| -p       *pidlist*  | 显示PID在*pidlist*列表中的进程               |
| -s       *sesslist* | 显示会话ID在*sesslist*列表中的进程           |
| -t       *ttylist*  | 显示终端ID在*ttylist*列表中的进程诶          |
| -u      *userlist*  | 显示有效用户ID在*userlist*列表中的进程       |
| -F                  | 显示更多额外输出（相对-f参数而言）           |
| -O      *format*    | 显示默认的输出列以及*format*列表指定的特定列 |
| -M                  | 显示进程的安全信息                           |
| -c                  | 显示进程的额外调度器信息                     |
| -f                  | 显示完整格式的输出                           |
| -j                  | 显示任务信息                                 |
| -l                  | 显示长列表                                   |
| -o        *format*  | 仅显示由*format*指定的列                     |
| -y                  | 不要显示进程标记                             |
| -Z                  | 显示安全标签信息                             |
| -H                  | 用层级格式显示进程（树状，用来显示父进程）   |
| -n       *namelist* | 定义了WCHAN列显示的值                        |
| -w                  | 采用宽输出模式，不限宽度显示                 |
| -L                  | 显示进程中的线程                             |
| -V                  | 显示ps命令的版本号                           |

组合使用

```bash
$ ps -ef
```

<img src="..\Linux命令行与shell脚本大全\img\ps-ef.png" >

* UID：启动这些进程的用户
* PID：进程的进程ID
* PPID：父进程的进程ID
* C：进程生命周期中CPU利用率
* STIME：进程启动时的系统时间
* TTY：进程启动时的终端设备
* TIME：进程需要的累计CPU时间
* CMD：启动的进程名称

采用-l参数，产生长格式输出。

<img src="..\Linux命令行与shell脚本大全\img\ps-l.png">

* F：内核分配给进程的系统标记
* S：进程状态（O代表运行、S代表休眠、R代表可运行和正等待 运行、Z代表僵化（进程已结束但父进程已不存在）、T代表停止。）
* PRI：进程的优先级
* NI：谦让度值用来参与决定优先级
* ADDR：进程的内存地址
* SZ：假如进程被换出，所需交换空间的大致大小
* WCHAN：进程休眠的内核函数的地址

<hr style="background-color:red;border:none">

#### BSD风格

| 参数                | 描述                                                    |
| ------------------- | ------------------------------------------------------- |
| T                   | 显示跟当前终端关联的所有进程                            |
| a                   | 显示跟任意终端关联的所有进程                            |
| g                   | 显示所有的进程，包括进程                                |
| r                   | 仅显示运行中的进程                                      |
| x                   | 显示所有的进程，甚至包括未分配任何终端的进程            |
| U        *userlist* | 显示归*userlist*列表中某用户ID所有的进程                |
| p        *pidlist*  | 显示PID在*pidlist*列表中的进程                          |
| t         *ttylist* | 显示所有关联的终端在*ttylist*列表中的进程               |
| O        *foramt*   | 除了默认输出的列外，还输出由*format*指定的列            |
| X                   | 按过去的Linuxi386寄存器格式显示                         |
| Z                   | 将安全信息添加到输出中                                  |
| j                   | 显示任务信息                                            |
| l                   | 采用长模式                                              |
| o      *foramt*     | 仅显示有*format*指定的列                                |
| s                   | 采用信号格式显示                                        |
| u                   | 采用基于用户的格式显示                                  |
| v                   | 采用虚拟内存格式显示                                    |
| N        *namelist* | 定义在WCHAN列中使用的值                                 |
| O        *order*    | 定义显示信息列的顺序                                    |
| S                   | 将数值信息从子进程加到父进程上，比如CPU和内存的使用情况 |
| c                   | 显示真实的命令名称（用以启动进程的程序名称）            |
| e                   | 显示命令的环境变量                                      |
| f                   | 用分层格式来显示进程，表明哪些进程启动了哪些进程        |
| h                   | 不显示头信息                                            |
| k       *sort*      | 指定用以将输出排序的列                                  |
| n                   | 和WCHAN信息一起显示出来，用数值来表示用户ID和组ID       |
| w                   | 为较宽屏幕显示宽输出                                    |
| H                   | 将线程按进程来显示                                      |
| m                   | 在进程后显示线程                                        |
| L                   | 列出所有格式指定符                                      |
| V                   | 显示ps命令的版本号                                      |

使用BSD参数时，ps命令自动模仿BSD格式。

**如     ps l**

<img src="..\Linux命令行与shell脚本大全\img\psBSD.png">

* VSZ：进程在内存中的大小，以千字节（KB）为单位
* RSS：进程在未换出时占用的物理内存
* STAT：代表当前进程状态的双字符状态码

<hr style="background-color:red;">

#### GNU长参数

| 参数                                 | 描述                                   |
| ------------------------------------ | -------------------------------------- |
| --deselect                           | 显示所有进程，除了命令行中列出的进程   |
| --Group               *grouplist*    | 显示组ID在*grplist*列表中的进程        |
| --User                 *userlist*    | 显示用户ID在*userlist*列表中的进程     |
| --group               *grplist*      | 显示有效组ID在*grplist*列表中的进程    |
| --pid                    *pidlist*   | 显示PID在*pidlist*列表中的进程         |
| --ppid                  *pidlist*    | 显示父PID在*pidlist*列表中的进程       |
| --sid                     *sidlist*  | 显示会话ID在*sidlist*列表中的进程      |
| --tty                      *ttylist* | 显示终端设备号在*ttylist*列表中的进程  |
| --user                  *userlist*   | 显示有效用户ID在*userlist*列表中的进程 |
| --format              *format*       | 仅显示由*format*指定的列               |
| --context                            | 显示额外的安全信息                     |
| --cols                   *n*         | 将屏幕宽度设置为n列                    |
| --columns           *n*              | 将屏幕宽度设置为n列                    |
| --cumulative                         | 包含已经停止的子进程信息               |
| --forset                             | 用层级结构显示出进程和父进程之间的关系 |
| --headers                            | 在每页输出中都显示列的头               |
| --no-headers                         | 不显示列的头                           |
| --lines                 *n*          | 将屏幕高度设置为n列                    |
| --rows                *n*            | 将屏幕高度设置为n排                    |
| --sort                *order*        | 指定将输出按哪列排序                   |
| --width            *n*               | 将屏幕宽度设置为n列                    |
| --help                               | 显示帮助信息                           |
| --info                               | 显示调试信息                           |
| --version                            | 显示ps命令的版本号                     |

### 4.2. top

**top**命令可以实时显示进程信息。

<img src="..\Linux命令行与shell脚本大全\img\top.png">

第一行显示系统的概况：显示当前时间、系统运行时间、登录用户数和系统平均负载。

第二行显示进程概要信息：top命令将进程叫做任务（tasks）。

第三行显示CPU概要信息。

最后一部分显示当前运行中的进程详细列表：

* PID：进程ID
* USER：进程属主的明名字
* PR：进程的优先级
* NI：进程的谦让度值
* VIRT：进程占用的虚拟内存总量
* RES：进程占用的物理内存总量
* SHR：进程和其他进程共享的内存总量
* S：进程状态（D代表可中断的休眠状态、S代表休眠状态、R代表可运行状态、T代表跟踪状态或停止状态、Z代表僵化状态）
* %CPU：进程使用的CPU时间比例
* %MEM：进程使用的内存占可用内存的比例
* TIME+：自进程启动到目前为止的CPU时间总量
* COMMAND：进程所对的命令名称，也就是启动进程的程序名

**按q键退出top**

### 4.3. kill

在linux中，进程之间通过信号来通信。

| 信号 | 名称 | 描述                         |
| ---- | ---- | ---------------------------- |
| 1    | HUP  | 挂起                         |
| 2    | INT  | 中断                         |
| 3    | QUIT | 结束运行                     |
| 9    | KILL | 无条件终止                   |
| 11   | SEGV | 段错误                       |
| 15   | TERM | 尽可能终止                   |
| 17   | STOP | 无条件停止运行，但不终止     |
| 18   | TSTP | 停止或暂停，但继续在后台运行 |
| 19   | CONT | 在STOP或TSTP之后恢复执行     |

**kill**命令可以通过进程ID给进程发信号。前提是必须是进程属主或登录为root用户。

```bash
$ kill 3940
```

-s参数指定其他信号

```bash
$ kill -s HUP 3940 
```

### 4.4. killall

**killall**命令支持通过进程名来结束进程，支持通配符。

```bash
$ killall *java
```

### 4.5. mount

**mount**命令用来挂载媒体。默认情况下，mount命令会输出当前系统上挂载设备列表。

<img src="..\Linux命令行与shell脚本大全\img\mount.png">

**mount**命令提供四部分信息：

* 媒体的设备文件名
* 媒体挂载到虚拟目录的挂载点
* 文件系统类型
* 已挂载媒体的访问状态

手动挂载媒体设备的基本命令（需要root用户身份登录，或sudo命令）

```bash
$ mount -t type device directory
```

**type**参数指定了磁盘被格式化的文件系统类型。

**mount命令的参数：**

| 参数                   | 描述                                                   |
| ---------------------- | ------------------------------------------------------ |
| -a                     | 挂载/etc/fstab文件中指定的所有文件系统                 |
| -f                     | 使mount命令模拟挂载设备，但并不真的挂载                |
| -F                     | 和-a参数一起使用时，会同时挂载所有文件系统             |
| -v                     | 详细模式，将会说明挂载设备的每一步                     |
| -I                     | 不启用任何/sbin/mount.filesystem下的文件系统帮助文件   |
| -l                     | 给ext2、ext3或XFS文件系统自动添加文件系统标签          |
| -n                     | 挂载设备，但不注册到/etc/mtab已挂载设备文件中          |
| -p             *num*   | 进行加密挂载时，从文件描述符*num*中获得密码短语        |
| -s                     | 忽略该文件系统不支持的挂载选项                         |
| -r                     | 将设备挂载为只读的                                     |
| -w                     | 将设备挂载为可读的（默认参数）                         |
| -L             *label* | 将设备按指定的*label*挂载                              |
| -U            *uuid*   | 将设备按指定的*uuid*挂载                               |
| -O                     | 和-a参数一起使用，限制命令只作用到特定的一组文件系统上 |
| -o                     | 给文件系统添加特定的选项                               |

-o参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。

* ro：以只读形式挂载
* rw：以读写形式挂载
* user：允许普通用户挂载文件系统
* check=none：挂载文件系统时不进行完整性校验
* loop：挂载一个文件

### 4.6. umount

卸载设备的命令时**umount**。

> 命令格式：
>
> **umount    [directory | device]**

**umount**命令支持通过设备文件或是挂载点来指定要卸载的设备。

### 4.7. df

**df**命令可以查看所有已挂载磁盘到的使用情况。

<img src="..\Linux命令行与shell脚本大全\img\df.png">

输出字段含义：

* 设备的设备文件位置
* 能容纳多少个1024字节大小的块
* 已用了多少个1024字节大小的块
* 还有多少个1024字节的块可以使用
* 已用空间所占的比例
* 设备挂载到了哪个挂载点上

```bash
$ df -h    # 用M代表兆字节，G代表吉字节，更加易读
```

### 4.8. du

**du**命令可以显示某个特定目录（默认是当前目录）的磁盘使用情况。

可以判断目录下是不是有超大文件。

```bash
$ du -ah
```

<img src="..\Linux命令行与shell脚本大全\img\du-ah.png">

### 4.9. sort

**sort**排序数据。**sort**命令是对数据进行排序的，默认语言的排序规则对文本文件中的数据行排序。

按月排序，**sort**能识别三字符的月份名。

```bash
$ sort -M file
```

### 4.10. grep

搜索文件。

>  命令格式：
>
>  **grep    [option]     pattern     [file]**

**grep**命令会在输入或指定的文件中查找包含配备指定模式的字符的行。支持正则表达式。

查看file中的包含s字符的行。

<img src="..\Linux命令行与shell脚本大全\img\grep.png">

反向搜索（输出不匹配该模式的行），加参数   -v

```bash
$ grep -v s file
```

显示匹配行所在行号，加参数   -n

```bash
$ grep -n s file  
```

输出有多少行含有匹配模式，加参数   -c

```bash
$ grep -c s file
```

### 4.11. 压缩数据

Linux文件压缩工具

| 工具     | 文件扩展名 | 描述                                              |
| -------- | ---------- | ------------------------------------------------- |
| bzip2    | .bz2       | 采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码 |
| compress | .Z         | 最初的Unix文件压缩工具，已经快没人用了            |
| gzip     | .gz        | GNU压缩工具，用Lempel-Ziv编码                     |
| zip      | .zip       | Windows上PKZIP工具的Unix实现                      |

#### 4.11.1. gzip

**gzip**用来压缩文件

```bash
$ gzip file
```

#### 4.11.2. gunzip

**gunzip**用来解压文件

```bash
$ gunzip file.gz
```

#### 4.11.3. gzcat

**gzcat**用来查看压缩过的文本文件的内容。

```bash
$ gzcat file.gz
```

### 4.12. tar

**tar**命令是Unix和Linux上最广泛的归档工具。

> 命令格式： 
>
> **tar   function  [option]   object1  object2 ...**

function参数定义了tar命令应该做什么。

**tar**命令的功能：

| 功能 | 长命令        | 描述                                                         |
| ---- | ------------- | ------------------------------------------------------------ |
| -A   | --concatenate | 将一个已有tar归档文件追加到另一个已有的tar归档文件           |
| -c   | --create      | 创建一个新的tar归档文件                                      |
| -d   | --diff        | 检查归档文件和文件系统的不同之处                             |
|      | --delete      | 从已有的tar归档文件中删除                                    |
| -r   | --append      | 追加文件到已有的tar归档文件末尾                              |
| -t   | --list        | 列出已有tar归档文件的内容                                    |
| -u   | --update      | 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 |
| -x   | --extract     | 从已有的tar归档文件中提取文件                                |

**tar**命令选项：


| 选项              | 描述                                |
| ----------------- | ----------------------------------- |
| -C        *dir*   | 切换到指定目录                      |
| -f         *file* | 输出结果到文件或设备*file*          |
| -j                | 将输出重定向给*bzip2*命令来压缩内容 |
| -p                | 保留所有文件权限                    |
| -v                | 在处理文件时显示文件                |
| -z                | 将输出重定向给*gzip*命令来解压内容  |

<hr>

解压.tgz文件

```bash
$ tar -zxvf fileName.tgz
```

## 5. 理解shell

### 5.1. shell的父子关系

输入bash、生成子shell。生成子shell进程时只有部分父进程的环境变量被复制到了子shell中。

**ps --forest**命令展示了shell间的嵌套关系。

<img src="..\Linux命令行与shell脚本大全\img\ps--forest.png">

bash的参数：

| 参数          | 描述                                        |
| ------------- | ------------------------------------------- |
| -c     string | 从string中读取命令并进行处理                |
| -i            | 启动一个能够接受用户输入的交互shell         |
| -l            | 以登录shell的形式启动                       |
| -r            | 启动一个受限shell，用户会被限制在默认目录中 |
| -s            | 从标准输入中读取命令                        |

退出命令**exit**

### 5.2. 进程列表

多个命令中间加分号；并用（）括起来。

```bash
$ (clear;pwd;ls;cd)
```

### 5.3. sleep

**sleep**命令接受一个参数，该参数是进程等待的秒数。

```bash
$ sleep  10
```

### 5.4. &

&符用于将进程挂到后台进行。

```bash
$ sleep 10&
```

### 5.5. jobs

**jobs**命令用来显示后台作业信息。它显示了作业号、作业状态以及对应命令。

```bash
$ jobs
$ jobs -l
```

***在CLI中运用子shell的创造性方法之一就是将进程列表置于后台模式。***

### 5.6. 协程

协程可以同时做两件事。

1. 在后台生成一个子shell
2. 在子shell中执行命令

### 5.7. coproc

**coproc**命令开启协程

```bash
$ coproc my_job {sleep 10; }
```

### 5.8. 外部命令

外部命令，也被称为文件系统命令，是存在于bash shell之外的命令。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。外部命令执行时，会创建一个子进程。

ps就是一个外部命令。

### 5.9. 内建命令

内建命令不需要子进程来执行。内建命令的执行速度要更快，效率也更高。

命令有多种实现，例如**echo**和**pwd**既有内建命令也有外部命令。

### 5.10. type

**type -a** 命令用来查看命令的不同实现。

```bash
$ type -a echo
```

<img src="..\Linux命令行与shell脚本大全\img\type-a.png">

### 5.11. which

**which**命令只显示出了外部命令文件。

```bash
$ which -a echo
```

<img src="..\Linux命令行与shell脚本大全\img\which-a.png">

### 5.12. history

**history**会输出已经执行的历史命令，通常会保存最近1000条命令。

！！会执行上一条命令。

！加数字执行指定历史命令。

### 5.13. alias

**alias**用来创建命令的别名。

```bash
$ alias li="ls -li"
```

**在用户目录的.bashrc中设置，实现永久配置。**

## 6. Linux环境变量

### 6.1. 什么是环境变量

bash shell用一个叫作环境变量（environment variable）的特性来存储有关shell会话和工作环境的信息。

在bash shell中，环境变量分为两类：

* 全局变量
* 局部变量

**全局环境变量对于shell会话和所有生成的子shell都是可见的。**

**局部变量则只对创建它们的shell可见。**

### 6.2. env

查看全局变量，可以用env或printenv。

```bash
$ env
$ printenv
```

<img src="..\Linux命令行与shell脚本大全\img\env.png">

### 6.3. printenv

显示个别环境变量

```bash
$ printenv HOME
```

<img src="..\Linux命令行与shell脚本大全\img\printenvHOME.png">

使用echo命令打印环境变量的值，环境变量的值用$符号引用。

```bash
$ echo $HOME
```

<img src="..\Linux命令行与shell脚本大全\img\echoHOME.png">

环境变量前加$可以将变量作为参数作为命令行参数。

<img src="..\Linux命令行与shell脚本大全\img\lsHOME.png">

**全局变量可作用于所有的子shell。**

### 6.4. set

**局部变量只能在定义它们的进程中可见。**

在Linux系统并没有一个只显示局部变量的命令。

**set**命令会显示为某个特定进程设置的所有环境变量，包括局部变量、环境变量以及用户定义变量。

```bash
$ set | head -10
```

<img src="..\Linux命令行与shell脚本大全\img\set.png">

### 6.5. 用户定义变量

#### 6.5.1. 用户定义局部变量

>  格式：
>
> $变量名=变量值

变量值可以是数字或字符串，当字符串之间有空格时必须加单引号。

**变量名、等号和值之间没有空格。**

子shell中设置的变量在父shell中不可用。退出子进程后自定义环境变量失效。

#### 6.5.2. 用户定义全局变量

创建全局环境变量的方法

1. 先创建一个局部环境变量
2. 使用expotr命令导出

```bash
$ a="Hello World"
$ expotr a
```

修改子shell中全局变量并不会影响到父shell中该变量的值。

子shell无法使用**export**命令改变父shell中全局变量的值。

### 6.6. 删除环境变量

```bash
$ unset [变量名]
```

**子进程中删除一个全局环境变量，这只对子进程有效。该全局环境变量在父进程中仍然有效。**

### 6.7. 默认环境变量

| 变量                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| CDPATH                | 冒号分隔的目录列表，作为cd命令的搜索路径                     |
| HOME                  | 当前用户的出目录                                             |
| IFS                   | shell用来将文本字符串分隔成字段的一系列字符                  |
| MAIL                  | 当前用户收件箱的文件名                                       |
| MAILPATH              | 冒号分隔的当前用户收件箱的文件名列表                         |
| OPTARG                | getopts命令处理的最后一个选项参数值                          |
| OPTIND                | getopts命令处理的最后一个选项参数值的索引号                  |
| PATH                  | shell命令查找命令的目录列表，由冒号分隔                      |
| PS1                   | shell命令行界面的主提示符                                    |
| PS2                   | shell命令行界面的次提示符                                    |
| BASH                  | 当前shell实例的全路径名                                      |
| BASH_ALIASES          | 含有当前已设置别名的关联数组                                 |
| BASH_ARGC             | 含有传入子函数或shell脚本的参数总数的数组变量                |
| BASH_ARCV             | 含有传入子函数或shell脚本的参数的数组变量                    |
| BASH_CMDS             | 关联数组，包含shell执行过的命令的所在位置                    |
| BASH_COMMAND          | shell正在执行的命令或马上就执行的命令                        |
| BASH_ENV              | 设置了的话，每个bash脚本会在运行前尝试运行该变量定义的启动文件 |
| BASH_EXECUTION_STRING | 使用bash -c选项传递过来的命令                                |
| BASH_LINENO           | 含有当前执行的shell函数所在源文件名的数组变量                |
| BASH_REMATCH          | 只读数组，在使用正则表达式的比较运算父=~进行肯定匹配时，包含了匹配到的模式和子模式 |
| BASH_SOURCE           | 含有当前正在执行的shell函数所在源文件名的数组变量            |
| BASH_SUBSHELL         | 当前子shell环境的嵌套级别（初始值是0）                       |
| BASH_VERSINFO         | 含有当前运行的bash shell的主版本号                           |
| BASH_XTRACEFD         | 若设置成了有效的文件描述符（0、1、2），则'set -x'调试选项生成的跟踪输出可被重定向。通常用来将跟踪输出到一个文件中 |
| BASHOPTS              | 当前启用的bash shell选项的列表                               |
| BASHPID               | 当前bash进程的PID                                            |
| COLUMNS               | 当前bash shell实例所用的终端宽度                             |

等等...

### 6.8. 设置PATH环境变量

PATH环境变量定义了用于进行命令和程序查找的目录。

添加PATH值：

```bash
$ PATH=$PATH:/home/turing/Script
```

这种对PATH变量的修改只能持续到退出或重启系统。

### 6.9. 系统环境变量

启动shell的三种方式：

* 登录时作为默认登录的shell
* 作为非登录shell的交互式shell
* 作为运行脚本的非交互式shelll

#### 6.9.1. 登录shell

登录shell会从5个不同的启动文件里读取命令：

* /etc/profile
* $HOME/.bash_profile
* $HOME/.bashrc
* $HOME/.bash_login
* $HOME/.profile

1. /etc/profile文件

/etc/profile文件是系统默认的bash shell的主启动文件。系统上每个用户登录时都会执行这个启动文件。

2. $HOME目录下的启动文件

同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环境变量。大多数Linux发行版只用这四个启动文件中的一到两个。

#### 6.9.2. 交互式shell

如果bash shell不是登录系统时启动的，那这个shell叫做交互式shell。它就不会访问/etc/profile文件，只会检查用户的HOME中的.bashrc文件。

.bashrc文件有两个作用：

* 查看/etc目录下通用的bashrc文件
* 为用户提供一个定制自己的命令别名和私有脚本函数的地方

#### 6.9.3. 非交互式shell

#### 6.9.4. 环境变量持久化

最好在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有的新的或修改过的全局变量设置放在这个文件中。

### 6.10. 数组变量

环境变量可以作为数组使用。

给某个环境变量设置多个值，把值放在括号里，值与值之间用空格分隔。

```bash
$ mytest=(one two three four five)
```

使用索引访问（索引值从0开始）

```bash
$ echo ${mytest[2]}
```

使用整个数组元素

```bash
$ echo ${mytest[*]}
```

改变某个索引位置的值

```bash
$ mytest[2]=seven
```

删除数组中的某个值

```bash
$ unset mytest[2]
$ unset mytest     # 删除整个数组
```

## 7. Linux文件权限

### 7.1. Linux的安全性

Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。

用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。

Linux系统使用一个专门的文件（/etc/passwd）来将用户的登录名匹配到对应的UID值。

<img src="..\Linux命令行与shell脚本大全\img\etc-passwd.png">

root用户账户是Linux系统的管理员，固定分配给它的UID是0。Linux系统会为各种各样的功能创建不同的用户账户，这些账户不是真正的用户，叫系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。

Linux为系统账户预留了500以下的UID值。

> /etc/passwd文件的字段包含：
>
> * 登录用户名
> * 用户密码
> * 用户账户的UID（数字形式）
> * 用户账户的组ID（GID）（数字形式）
> * 用户账户的文本描述（称为备注字段）
> * 用户HOME目录的位置
> * 用户默认的shell

/etc/passwd文件中的密码字段都被设置成了x。

**绝大数Linux系统都将用户密码保存在（/etc/shadow）。只有root用户可以访问。**

/etc/shadow文件为系统上的每个用户账户都保存了一条记录。

<img src="..\Linux命令行与shell脚本大全\img\etc-shadow.png">

> /etc/shadow文件的每个记录都有9个字段：
>
> * 与/etc/passwd文件中的登录名字段对应的登录名
> * 加密后的密码
> * 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）
> * 多少天后才能更改密码
> * 多少天后必须更改密码
> * 密码过期前提前多少天提醒用户更改密码
> * 密码过期后多少天禁用用户账户
> * 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）
> * 预留字段给将来使用

### 7.2. 添加用户

添加用户的主要工具是**useradd**。**useradd**命令使用系统默认值以及命令行参数来设置用户账户。系统默认值被设置在/etc/default/useradd文件中。可以使用-D选项的**useradd**命令查看所用Linux中的默认值。

<img src="..\Linux命令行与shell脚本大全\img\useradd-D.png">

>  默认值的内容：
>
> 1. 新用户会被添加到GID为100的公共组
> 2. 新用户的HOME目录会位于/home/用户名
> 3. 新用户帐号密码在过期后不会被禁用
> 4. 新用户账户未被设置过期日期
> 5. 新用户的默认shell为/sh
> 6. 系统会将/etc/skel目录下的内容复制到用户的HOME目录下
>
> <img src="..\Linux命令行与shell脚本大全\img\etc-skel.png">
>
> 7. 系统不会为用户在mail目录下创建一个用于接受邮件的文件

**useradd**命令不会创建HOME目录，加上选项**-m**会使其创建HOME目录。

| 参数                            | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| -c             *comment*        | 给新用户添加备注                                             |
| -d             *home_dir*       | 为主目录指定一个名字（不想用登录名作为主目录名）             |
| -e             *expire_date*    | 用YYYY-MM-DD格式指定一个账户过期的日期                       |
| -f              *inactive_days* | 指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立刻禁用，-1表示禁用这个功能 |
| -g              *initial_group* | 指定用户登录组的GID或组名                                    |
| -G             *group    ...*   | 指定用户除登录组之外所属的一个或多个附加组                   |
| -k                              | 必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录  |
| -m                              | 创建用户的HOME目录                                           |
| -M                              | 不创建用户的HOME目录（默认）                                 |
| -n                              | 创建一个与用户登录名相同的组名                               |
| -r                              | 创建系统账户                                                 |
| -p            *passwd*          | 为用户指定密码                                               |
| -s             *shell*          | 指定默认的登录shell                                          |
| -u            *uid*             | 为账户指定唯一的UID                                          |

使用-D修改系统默认的新用户设置。

| 参数                        | 描述                                         |
| --------------------------- | -------------------------------------------- |
| -b         *default_home*   | 更改默认的创建用户HOME目录的位置             |
| -e        *expiration_date* | 更改默认的新账户的过期日期                   |
| -f         *inactive*       | 更改默认的新账户从密码过期到账户被禁用的天数 |
| -g         *group*          | 更改默认的组名称或GID                        |
| -s         *shell*          | 更改默认的登录shell                          |

```bash
$ useradd -D -s /bin/tsch
```

### 7.3. 删除用户

**userdel**命令用来删除用户，默认情况下，**userdel**只会删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件。

加上-r参数**userdel**会删除用户的HOME目录以及邮件目录。

```bash
$ userdel -r test
```

### 7.4. 修改账户

>  修改工具
>
> 1. usermod      修改用户账户的字段，还可以指定组以及附加组的所属关系
> 2. passwd         修改已有用户的密码
> 3. chpasswd     从文件中读取登录密码对，并更新密码
> 4. chage            修改密码的过期日期
> 5. chfn               修改用户账户的备注信息
> 6. chsh              修改用户账户的默认登录shell

#### 7.4.1. usermod

**usermod**是修改工具中功能最强大的一个，它可以修改/etc/passwd文件中大部分字段。

| 参数 | 描述                     |
| ---- | ------------------------ |
| -c   | 修改备注字段             |
| -e   | 修改过期日期             |
| -g   | 修改默认的登录组         |
| -l   | 修改用户账户的登录名     |
| -L   | 锁定账户，使用户无法登录 |
| -p   | 修改账户密码             |
| -U   | 解除账户，使用户可以登录 |

#### 7.4.2. passwd和chpasswd

**passwd**命令只会修改自己的密码，系统上的任何用户都能修改自己的密码，只有root用户才有权限修改别人的密码。-e参数强制用户下次登录时修改密码。

大量用户修改密码，可以使用chpasswd命令，它可以从标准输入自动读取登录名和密码对（由分号分隔）列表，给密码加密，然后为用户账户设置。

```bash
$ chpasswd < users.txt     # users.txt  (userID:passwd)
```

#### 7.4.3. chsh、chfn和chage

**chsh**命令用来快速修改默认用户的shell，必须用shell的全路径作为参数。

**chfn**命令会将用于Unix的finger命令的信息存进备注字段。

**finger**命令可以非常方便地查看Linux系统上的用户信息。

**chage**命令用来帮助管理账户的有效期。

| 参数 | 描述                               |
| ---- | ---------------------------------- |
| -d   | 设置上次修改密码到现在的天数       |
| -E   | 设置密码过期的日期                 |
| -I   | 设置密码过期到锁定账户的天数       |
| -m   | 设置修改密码之间最少要多少天       |
| -w   | 设置密码过期前多久开始出现提醒信息 |

>  chage命令的日期格式：
>
> * YYYY-MM-DD
> * 从1970年1月1日起到该日期的天数

### 7.5. Linux组

Linux组概念用来解决共享资源以及安全性的问题。

每个组都有唯一的GID。除了GID，每个组还有唯一的组名。

#### 7.5.1. /etc/group

/etc/group文件包含系统上用到的每个组的信息。

<img src="..\Linux命令行与shell脚本大全\img\etc-group.png">

> /etc/group文件有4个字段：
>
> * 组名
> * 组密码
> * GID
> * 属于该组的用户列表

#### 7.5.2. 创建新组

**groupadd**命令用在来系统上创建新组。

使用**usermod**将用户分配到创建的组内。

#### 7.5.3. 修改组

**groupmod**命令可以修改已有组的GID（-g）或组名（-n）。

### 7.6. 文件权限

#### 7.6.1. 文件权限符

<img src="..\Linux命令行与shell脚本大全\img\ls-l.png">

<img src="..\Linux命令行与shell脚本大全\img\文件权限.png">

> 第一个字段就是描述文件和目录权限的编码。（-）
>
> * -代表文件
> * d代表目录
> * l代表链接
> * c代表字符型设备
> * b代表块设备
> * n代表网路设备
>
> 之后有3组三字符编码，每一组定义了3中访问权限：
>
> * r代表对象是可读的
> * w代表对象是可写的
> * x代表对象是可执行的
>
> 若没有某种权限用-代替，3组权限分别代表3个安全级别：
>
> * 对象的属主
> * 对象的属组
> * 系统的其他用户

#### 7.6.2. 默认文件权限

**umask**命令来设置所创建文件和目录的默认权限。

**umask**命令可以显示和设置默认权限。

<img src="..\Linux命令行与shell脚本大全\img\umask.png">

> 四位数字，第一位代表一项特别的安全特性，叫**粘着位**。后面的3位表示文件或目录对应的**umask**八进制值。
>
> 八进制模式的安全设置先获取这3个rwx权限的值，然后将其转换成3位二进制值，用一个八进制值来表示。在这个二进制表示中，每个位置代表一个二进制位。
>
> | 权限 | 二进制值 | 八进制值 |       描述       |
> | :--: | :------: | :------: | :--------------: |
> | ---  |   000    |    0     |   没有任何权限   |
> | --x  |   001    |    1     |   只有执行权限   |
> | -w-  |   010    |    2     |   只有写入权限   |
> | -wx  |   011    |    3     | 有写入和执行权限 |
> | r--  |   100    |    4     |   只有读取权限   |
> | r-x  |   101    |    5     | 有读取和执行权限 |
> | rw-  |   110    |    6     | 有读取和写入权限 |
> | rwx  |   111    |    7     |    有全部权限    |

umask值只是个掩码。

文件的全权限是666，上面umask的默认值取后3位，即002。用666减去002得到664，根据上表可知默认创建的文件权限为-rw-rw-r--。

<img src="..\Linux命令行与shell脚本大全\img\默认创建文件权限.png">

目录的全权限为777。与上面的计算方式一样。可知目录权限为drwxrwxr-x。

<img src="..\Linux命令行与shell脚本大全\img\默认创建目录权限.png">

#### 7.6.3. 修改默认创建权限

```bash
$ umask 026   # umask后跟一个三位八进制数
```

### 7.7. 改变安全性设置

#### 7.7.1. 改变权限

**chmod**命令用来改变文件和目录的安全性设置。

> 命令格式：
>
> chmod   *options*   *mode*    file

mode参数可以使用八进制模式或符号模式进入安全性设置。

```bash
$ chmod 666 file
```

符号模式

> 格式：
>
> [ugoa...]   [[+-=] [rwxXstugo...]] 

第一组字符定义了权限作用的对象

> * u代表用户
> * g代表组
> * o代表其他
> * a代表上述所有

第二个的符号代表增加权限（+），减少权限（-），将权限设置成后面的值（=）。

第三个字符代表作用在文件上的权限。

> * X：如果对象是目录或者它已有执行权限，赋予执行权限
> * s：运行时重新设置UID或GID
> * t：保留文件或目录
> * u：设置属主权限
> * g：设置组权限
> * o：设置其他用户权限

```bash
$ chmod u+x file
```

#### 7.7.2. 改变所属关系

**chown** 命令用来改变文件的属主。

> chown   *options*   *owner[.group]   file*
>
> ```bash
> $ chown jason file
> ```

-R选项配合通配符可以递归地改变子目录和文件的所属关系。-h选项可以改变该文件的所有符号链接文件的所属关系。

**chgrp**命令用来改变文件的默认属主。

### 7.8. 共享文件

Linux上共享文件的方式是创建组。

Linux为每个文件和目录存储了3个额外的信息位。

* 设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。
* 设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。
* 粘着位：进程结束后文件还驻留（粘着）在内存中。

## 8. 管理文件系统

### 8.1.

## 9. 安装软件程序

TODO

## 10. 使用编辑器

TODO

# 第二部分    shell脚本编程基础

## 11. 构建基本脚本

### 11.1. 使用多个命令

命令之间用分号隔开。

```bash
$ date ; who
```

### 11.2. shell脚本

创建shell脚本文件，一般以.sh作为文件结尾。

文件的第一行，指明使用何种shell运行。

```bash
#!/bin/bash
date +"%Y-%m-%d  %p  %H:%M:%S"
```

运行方式：

1. 直接将文件传递给bash

```bash
$ bash test.sh
```

2. chmod命令赋予文件可执行权

```bash
$ chmod u+x test.sh     # 赋予test.sh文件属主可执行权

$./test.sh              # 执行
```



**要让shell找到test脚本的两种做法：**

1. **将shell脚本文件所处的目录添加到PATH环境变量中**
2. **在提示符中使用绝对路径或相对路径来引用shell脚本文件**   （./ 是相对路径）

### 11.3. 显示消息

echo命令输出含单引号的字符。

```bash
$ echo " you're apple "
```

echo命令输出含\$符号的字符。\$符前叫\转义，不然shell会找$符引用的变量。

```bash
$ echo " you're apple is \$5 "
```

echo命令的-n参数会让输出不换行。

```bash
$ echo -n "Hello "; echo "World"
```

echo命令可以写进shell脚本中。

### 11.4. 使用变量

1. 环境变量

​	在脚本中在环境变量之前加上美元符（$）来使用定义的环境变量。

```bash
#!/bin/bash

echo $HOME
```



​	在双引号中使用美元符引用变量，变量引用值依然生效。

2. 自定义变量

​	shell脚本允许在脚本文件中自定义自己的用户变量。

​	变量声明规则，“变量名=值” 。自定义变量的生命周期只在存在脚本运行的过程中。

```shell
#!/bin/bash

var1=100
var2=-57
var3=hello
var4="This piece is \$5"
```

### 11.5. 命令替换

shell脚本最有用的特性之一就是可以从命令中提取信息，并将其赋给变量。

**两种格式：**

1. **反引号符（`）**

```bash
today=`date +"%Y-%m-%d"`
```

2. **$（）格式**

```bash
today=$(date +"%Y-%m-%d")
```

### 11.6. 重定向输入和输出

#### 11.6.1. 输出重定向  >

使用（>）将命令的输出重定向输出到一个文件中。

> 格式：
>
> ```bash
> $ command > outputfile
> ```

注意   (>)  会覆盖指定输出文件中的内容，如果不想覆盖可以使用（>>）追加数据。

#### 11.6.2. 输入重定向   <

输入重定向将文件的内容重定向到命令。

> 格式：
>
> ```bash
> $ command < inputfile
> ```

**内联重定向。这种方法无需使用文件进行重定向，只需在命令行中指定用于输入的重定向的数据就可以了。内联重定向符是（<<）。除此之外，必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可以作为文本标记，但在数据的开始和结尾文本标记必须一致。**

**shell会用PS2环境变量中定义的次提示符来提示输入数据。**

> 格式：
>
> ```bash
> $ command << EOF
> $ > data
> $ > EOF
> ```

### 11.7. 管道    |

直接将一个命令的输出重定向到另一个命令。可以使用（|）符。

> 格式：
>
> ```bash
> $ command1 | command2
> ```

常使用管道将一些有大量输出的命令重定向到more。

```bash
$ ls -l | more
```

### 11.8. 数学运算

#### 11.8.1. expr命令

expr命令允许在命令行上处理数学表达式。

```bash
$ expr 1 + 5          # 数字与运算符之间必须有空格 
```

expr命令能够识别少数的数学和字符串操作符。

| 操作符                     | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| a  +  b                    | 返回a+b的值                                                  |
| a  -  b                    | 返回a-b的值                                                  |
| a  \\*  b                  | 返回a*b的值                                                  |
| a  /   b                   | 返回a除b的商                                                 |
| a  %  b                    | 返回a除b的余数                                               |
| a  \|  b                   | 如果a既不是null也不是0值，返回a，否则返回b                   |
| a  &  b                    | 如果没有参数是null或0值，返回a，否则返回0                    |
| a  <   b                   | 如果a小于b，返回1；否则返回0                                 |
| a  <=   b                  | 如果a小于等于b，返回1；否则返回0                             |
| a   >  b                   | 如果a大于b，返回1；否则返回0                                 |
| a  >=  b                   | 如果a大于等于b，返回1；否则返回0                             |
| a  =  b                    | 如果a等于b，返回1；否则返回0                                 |
| a  !=  b                   | 如果a不等于b，返回1；否则返回0                               |
| STRING   :  REGEXP         | 如果REGEXP匹配到了STRING中的某个模式，返回该模式匹配         |
| math  STRING  REGEXP       | 如果REGEXP匹配到了STRING中的某个模式，返回该模式匹配         |
| substr STRING  POS  LENGTH | 返回起始位置POS（从1开始计数）、长度为LENGTH个字符的子字符串 |
| index STRING  CHARS        | 返回在STRING中找到CHARS字符串的位置；否则返回0               |
| length  STRING             | 返回字符串STRING的数值长度                                   |
| +  TOKEN                   | 将TOKEN解释成字符串，即使是个关键字                          |
| （EXPRESSION）             | 返回EXPRESSION的值                                           |

在处理乘法操作的时候。使用反斜线（\）转义字符对*号进行转义。

```bash
$ expr 3 \* 5
```

#### 11.8.2. 脚本中的数学运算

​		**在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（$[  option]）将数学表达式围起来。**

```bash
$ var=$[1 + 5]
$ echo var
```

#### 11.8.3. 浮点数运算

##### 1.  bc

bash计算器能够识别：

* 数字（整数或浮点数）
* 变量（简单变量和数组）
* 注释（以#或C语言中的/**/开始的行）
* 表达式
* 编程语句（如if-then语句）
* 函数

<img src="..\Linux命令行与shell脚本大全\img\bc.png">

**浮点运算是由内建变量scale控制的。scale变量的默认值为0，scale变量可以指定浮点数计算结果的位数。**

**如：scale=4**

**-q参数可以不显示冗长的欢迎信息。**

```bash
$ bc -q
```

bash计算器支持变量

<img src="..\Linux命令行与shell脚本大全\img\bc-q.png">

**输入quit退出bc。**

##### 2.在脚本中使用bc

​		可以使用命令替换运行的bc命令。option允许设置变量，如果不止一个变量，可以用分号分隔。expression参数定义了通过bc执行的数学表达式。

>  格式：
>
> ```bash
> $ var=$(echo "option ; expression" | bc)
> ```

```bash
#!/bin/bash
target=3.44
var=$(echo "scale=4; $target / 5" | bc)  			# scale变量是结果值的位数

echo $var
```

在一个命令行中列出多个表达式。

> 格式：
>
> ```bash
> var=$(bc << EOF
> options
> statements
> expressions
> EOF
> )
> ```

```bash
#!/bin/bash

var1=100
var2=200
var3=45.5
var4=54.5

var5=$(bc << EOF
scale = 4
a1=($var1 + $var2)
b1=($var3 + $var4)
a1 + b1
EOF
)

echo "var5=$var5"
```

### 11.9. 退出脚本

shell中运行的每个命令都使用退出状态码告诉shell它已经运行完毕。

#### 11.9.1. 查看退出状态码

Linux提供了一个专门的变量（$?）来保存上个已执行命令的退出状态码。

| 状态码 | 描述                       |
| ------ | -------------------------- |
| 0      | 命令成功结束               |
| 1      | 一般性未知错误             |
| 2      | 不适合的shell命令          |
| 126    | 命令不可执行               |
| 127    | 没找到命令                 |
| 128    | 无效的退出参数             |
| 128+x  | 与Linux信号x相关的严重错误 |
| 130    | 通过Ctrl+C终止的命令       |
| 255    | 正常范围之外的退出状态码   |

#### 11.9.2. exit命令

默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出。

exit命令允许在脚本结束时指定一个退出状态码。

```bash
#!/bin/bash
date 

exit 5
```

exit引用变量 

```bash
#!/bin/bash
date 

var1=3

exit $var
```

**退出码值的范围在0~255之间。当大于这个范围后，实际退出码的值是用退出码与256取余得到的。**

## 12. 使用结构化命令

### 12.1. if-then语句

> 格式：
>
> ```bash
> if  command
> then
> 	commands
> fi
> ```

如果，**if后面的命令的退出码是0（命令成功执行），位于then后的命令就会被执行。如果该命令的退出码是其他值，then后的命令就不会执行。**fi语句表示if-then语句到此结束。

在then部分可以使用不止一条命令。

### 12.2. if-then-else

> 格式：
>
> ```bash
> if command
> then 
> 	commands
> else
> 	commands
> fi
> ```

当if语句中的命令返回值退出状态码为0时，then部分的命令会被执行。当if语句中的命令返回非零状态码时，shell会执行else部分中的命令。

### 12.3. 嵌套if

嵌套的if-then语句位于if-then-else语句中的else代码块中。

> 格式：
>
> ```bash
> if command1
> then
> 	commands
> else
> 	commands
> 	if command2
> 	then
> 		commands
> 	else
> 		commands
> 		...
> 	fi
> fi	
> ```

> 另一种格式：
>
> ```bash
> if command1
> then
>  	commands
> elif command2
> then 
> 	commands
> fi
> ```

### 12.4. test命令

if-then语句不能测试命令退出状态码之外的条件。test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。如果条件不成立，test命令就会退出并返回非零的退出状态码。**test命令可以用方括号代替。条件两端必须留有空格。**

> 格式：
>
> ```bash
> test condition   
> 
> [ condition ]  
> ```

如果不写condition部分，它会以非零的退出状态码退出，并执行else语句块。

```bash
#!/bin/bash
if test   # [  ]
then 
	echo "test return is 0"
else
	echo "test return don't  0"
fi
```

<img src="..\Linux命令行与shell脚本大全\img\test-null.png">

<hr>

可以使用test命令确认变量中是否有值。

```bash
#!/bin/bash
var=1

if [ $var ]
then 
	echo "test return is 0"
else
	echo "test return don't  0"
fi
```

<img src="..\Linux命令行与shell脚本大全\img\test-full.png">

<hr>

**test命令可以判断三类条件：**


* **数值比较**
* **字符串比较**
* **文件比较**

#### 12.4.1. 数值比较

| 比较              | 描述                   |
| ----------------- | ---------------------- |
| n1   -eq    n2    | 检查n1是否与n2相等     |
| n1   -ge    n2    | 检查n1是否大于或等于n2 |
| n1   -gt     n2   | 检查n1是否大于n2       |
| n1    -le     n2  | 检查n1是否小于或等于n2 |
| n1    -lt      n2 | 检查n1是否小于n2       |
| n1    -ne    n2   | 检查n1是否不等于n2     |

数值条件可以用在数字和变量上。可以使用数学符号或者上述比较符。

```bash
1	#!/bin/bash
2	var1=1
3	var2=2
4	#
5	if test $var1 -eq $var2
6	then 
7		echo "var1 = var2"
8	else
9		echo "var1 != var2"
10	fi
11	
12	#
13	if test $var2 > 4
14	then
15		echo "var2 > 4"
16	else
17		echo "var2 < 4"
18	fi
```

运行结果

<img src="..\Linux命令行与shell脚本大全\img\var1比较var2.png">

**使用比较test功能的符号时，不能比较浮点值。使用数学比较符时可以正常比较。**

<img src="..\Linux命令行与shell脚本大全\img\f-sh2.png">

<img src="..\Linux命令行与shell脚本大全\img\f-sh1.png">

#### 12.4.2. 字符串比较

| 比较            | 描述                   |
| --------------- | ---------------------- |
| str1   =   str2 | 检查str1是否和str2相同 |
| str1   !=  str2 | 检查str1是否和str2不同 |
| str1   <   str2 | 检查str1是否比str2小   |
| str1   >   str2 | 检查str1是否比str2大   |
| -n   str1       | 检查str1的长度是否非0  |
| -z   str1       | 检查str1的长度是否为0  |

1. 字符串相等性
2. 字符串顺序
   * 大于号和小于号必须转义（否则shell会当成重定向符）
   * 大于和小于顺序和sort命令采取的不同

​		比较使用的标准是ASCII顺序，根据每个字符的ASCII数值来决定排序的结果。

3. 字符串大小

​	-n和-z可以检查一个变量是否含有数据。

#### 12.4.3. 文本比较

| 比较                 | 描述                                     |
| -------------------- | ---------------------------------------- |
| -d      *file*       | 检查file是否存在并是一个目录             |
| -e      *file*       | 检查file是否存在                         |
| -f      *file*       | 检查file是否存在并是一个文件             |
| -r      *file*       | 检查file是否存在并可读                   |
| -s      *file*       | 检查file是否存在并非空                   |
| -w      *file*       | 检查file是否存在并可写                   |
| -x      *file*       | 检查file是否存在并可执行                 |
| -O      *file*       | 检查file是否存在并属当前用户所有         |
| -G      *file*       | 检查file是否存在并且默认组与当前用户相同 |
| file1   -nt    file2 | 检查file1是否比file2新                   |
| file1   -ot    file2 | 检查file1是否比file2旧                   |

### 12.5. 复合条件测试

> [ condition1 ]  && [ condition2 ] 
>
> [ condition1 ]  ||  [ condition2 ] 

### 12.6. if-then的高级特性

1. 用于数学表达式的双括号
2. 用于高级字符串处理功能的双方括号

#### 12.6.1. 双括号

> 格式：
>
> (( expression ))

expression可以是任意的数学赋值或比较表达式。

双括号支持的一些运算符。

| 符号  | 描述     |
| ----- | -------- |
| val++ | 后增     |
| val-- | 后减     |
| ++val | 先增     |
| --val | 先减     |
| !     | 逻辑取反 |
| ~     | 位取反   |
| **    | 幂运算   |
| <<    | 位左移   |
| >>    | 位右移   |
| &     | 位布尔和 |
| \|    | 位布尔或 |
| &&    | 逻辑和   |
| \|\|  | 逻辑或   |

#### 12.6.2. 双方括号

> 格式：
>
> [[  expreession  ]]

双方括号里的expression使用了test命令中采用的标准字符比较，并且支持模式匹配。在模式匹配中，可以定义一个正则表达式。

```bash
if [[ $USER == r* ]]
```

### 12.7. case命令

case命令采用列表格式来检查单个变量的多个值。竖线操作符在一行中分隔出多个模式。星号会捕获所有与已知模式不匹配的值。

> 格式：
>
> ```bash
> case var in
> pattren1 | pattern2)
> 	command1;;
> pattern3)
> 	command2;;
> *) default commands;;
> esac
> ```

```bash
1	# /bin/bash
2	#
3	#
4	
5	case $HOME in
6	rich)
7		echo "user is rich";;
8	turing)
9		echo "user is turing";;
10	*)
11		echo "user is others ";;
12	esac
```

## 13. 更多结构化命令

### 13.1. for命令

> 格式：
>
> ```bash
> for var in list
> do 
> 	conmands
> done
> ```

var变量每次迭代list中的一个值，用$var可以取到每个值。do和done之间的命令可以是一条或多个bash shell命令。

> ```bash
> for var in list ; do   # 另一种写法
> ```

#### 13.1.1. 读取列表中的值

for命令最基本的用法就是遍历for命令自身定义的一系列值。

```bash
1	#!/bin/bash
2	#
3	#
4	for var in Aim Frank Tom Bob Gio
5	do
6		echo -n "Hi $var"
7		echo ", are you ok?"
8	done
```

执行结果：

<img src="..\Linux命令行与shell脚本大全\img\for.png">">

#### 13.1.2. 读取列表中的复杂值

**当列表字符中包含单引号时，使用：**

* **使用转义字符（反斜线）将单引号转义**
* **使用双引号来定义用到的单引号的值**

**for循环假定每个值都是用空格来分隔的。**

**若有包含空格的数据，使用双引号把值包裹起来。**

#### 13.1.3. 从变量读取列表

从list变量中读取人名。

```bash
1	#!/bin/bash
2	#
3	#
4	list="Aim Frank Tom Bob Gio"
5	
6	for var in $list
7	do
8		echo -n "Hi $var"
9		echo ", are you ok?"
10	done
```

#### 13.1.4. 从命令中读取值

可以使用命令来替换执行任何能产生输出的命令，然后在for命令中使用该命令的输出。

<img src="..\Linux命令行与shell脚本大全\img\for2.png">

#### 13.1.5. 更改字段分隔符

默认情况下，bash shell会将以下字符当作字段分隔符：

* 空格
* 制表符
* 换行符

可以在shell脚本中临时更改IFS环境变量来限制被bash shell当作字段分隔符的字符。

<img src="..\Linux命令行与shell脚本大全\img\for3.png">

**需要指定多个IFS字符。**

```bash
IFS=$'\n':;"  # 使用换行符、冒号、分号和双引号分隔

IFS=:         # 使用冒号分隔
```

#### 13.1.6. 用通配符读取目录

```bash
1	#!/bin/bash
2	
3	for file in /root/*
4	do
5		if [ -d "$file" ]
6		then 
7			echo "$file is a directory"
8		elif [ -f "$file" ]
9		then
10			echo "$file is a file"
11		fi
12	done
```

当目录或者文件名中包含空格时，需要将$file变量用双引号括起来。

**还可以在in后面有多个模式匹配。**

### 13.2. C语言风格的for命令

#### 13.2.1. 格式

bash shell支持一种C语言风格类似的for循环。

> 格式：
>
> ```bash
> for( ( variable  assignment ; condition ; iteration process ) )
> ```

```bash
1	#!/bin/bash
2	
3	
4	# C风格的for循环
5	
6	for (( a = 1 ; a < 10 ; a++ ))
7	do
8		echo "The number is $a "
9	done
```

#### 13.2.2. 使用多个变量

```bash
1	#!/bin/bash
2	
3	for (( a = 1, b = 10; a<=10 && b>0; a++, b--))
4	do
5		echo "The a is $a , b is $b"
6	done
7	
```

### 13.3. while命令

> 格式：
>
> ```bash
> while test command
> do
> 	commands
> done
> ```

```bash
1	#!/bin/bash
2	
3	a=10
4	
5	while [ $a -gt 0 ]
6	do
7		echo "a is $a"
8		a=$[ $a - 1 ]
9	done
```

<img src="..\Linux命令行与shell脚本大全\img\while.png">

#### 13.3.2. 使用多个测试命令

while命令允许在while语句行定义多个test命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。

如：

```bash
1	#!/bin/bash
2	
3	a=10
4	b=5
5	
6	while [ $a \> 0 ]
7		  [ $b \> 0 ]    # 根据此条件决定循环次数
8	do
9		echo "a = $a , b = $b"
10		a=$[ $a - 1 ]
11		b=$[ $b - 1 ]
12	done
```

根据b的输出5行。

<img src="..\Linux命令行与shell脚本大全\img\while1.png">

### 13.4. until命令

until命令和while命令相反，until命令要求指定一个返回非零退出状态码的测试命令。

> 格式：
>
> ```bash
> until  test  commands
> do
> 	other  commands
> done
> ```

和while一样until也可以允许有多个test命令，最后一个命令的退出状态码决定循环次数。

```bash
1	#!bin/bash
2	
3	a=10
4	b=5
5	
6	until [ $a -eq 0 ]
7		  [ $b -eq 0 ]
8	do
9		echo "a = $a , b = $b"
10		a=$[ $a - 1 ]
11		b=$[ $b - 1 ]
12	done
```

<img src="..\Linux命令行与shell脚本大全\img\until.png">

### 13.5. 嵌套循环

for、while、until循环可以相互嵌套使用。

如九九乘法表。

```bash
1	#!/bin/bash
2	
3	#定义起始
4	a=1
5	b=1
6	
7	while (( $a < 10 ))
8	do
9		while (( $b <= $a ))
10		do
11			res=$[ $a * $b ]
12			echo -n " $b * $a = $res "
13			b=$[ $b + 1 ]
14		done
15		a=$[ $a+1 ]
16		b=1
17		echo 
18	done
```

### 13.6. 处理文件数据

```bash
1	#!bin/bash
2	
3	IFSOLD=$IFS
4	IFS=$'\n'
5	
6	for entry in $(cat /etc/passwd)
7	do
8		echo "Value in $entry - "
9		IFS=:
10		for value in $entry
11		do
12			echo "        $value"
13		done
14	done
```

>  所使用技术：
>
> * 使用嵌套循环
> * 修改IFS环境变量

效果如下：

<img src="..\Linux命令行与shell脚本大全\img\数据循环处理.png">

### 13.7. 控制循环

>  两个控制循环内部情况命令：
>
> * break 命令
> * contiune 命令

#### 13.7.1. break命令

break命令用于跳出任意类型的循环。包括while和until。

当break作用于嵌套循环中的内层循环时，默认只结束所在层的循环。

如果在内层循环想结束外部循环时，break命令接受单个命令行参数值：

```bash
break n   # n为数字 n值为多少表示要跳出多少的循环层数
```

#### 13.7.2. contiune命令

contiune命令可以终止当此循环，整个循环继续进行。

和break命令一样，接受单个命令行参数值：

```bash
contiune n   # n为数字
```

### 13.8. 循环输出

可以利用管道将循环处理的结果输出到文件中。只需要在done后跟上管道符和文件名。

如：

```bash
1	#!bin/bash
2	
3	for (( a=10 ; a>0 ; a-- ))
4	do
5		echo "a is $a"
6		if [ $a -eq 5 ]
7		then 
8			break
9		fi
10	done > file4.txt
```

### 13.9. 实例

#### 13.9.1. 查找可执行文件

```bash
1	#!/bin/bash
2	# finding files in the PATH
3	
4	IFS=:
5	for folder in $PATH
6	do
7		echo " $folder: "
8		for file in $folder/*
9		do
10			if [ -x $file ]
11			then
12				echo "    $file"
13			fi
14		done
15	done
```

#### 13.9.2. 创建多个用户账户

```bash
1	#!/bin/bash
2	# process new user accounts
3	
4	input="users.csv"
5	while IFS=',' read -r userid name
6	do
7		echo "adding $userid"
8		useradd -c "$name" -m $userid
9	done < "$input"
```

users.csv文件

```bash
1	rich,Richard Blum
2	tim,Timothy Breanahan
3	barbara,Barbara Blum
4	christine,Christine Bresnahan
```

## 14. 处理用户输入

### 14.1. 命令行参数

向shell脚本传递数据的最基本的方法是使用命令行参数。脚本会通过特殊的变量来处理命令行参数。

#### 14.1.1. 读取参数

bash shell接受位置参到脚本中，位置参数是标准的数字：$0是程序名，$1是第一个参数，$2是第二个参数...一直到第九个参数$9。变量之间用空格分隔。

传递的参数可以是字符串，当字符串中包含空格时，需要将字符串用单双引号括起来。

当传递的参数超过9个后必须在变量数字的周围加上花括号，如${10}。

```bash
1	#!/bin/bash
2	
3	sum=$[ ${10} * ${11} ]
4	echo "{10} is ${10}"
5	echo "{11} is ${11}"
6	echo "{10} * {11} is $sum"
```

<img src="..\Linux命令行与shell脚本大全\img\传递多参数.png">

#### 14.1.2. 读取脚本名

$0参数可以获取shell脚本在命令行启动的脚本名。<img src="..\Linux命令行与shell脚本大全\img\脚本名.png">

当使用另一种方式启动脚本时，会将命令也打印出来。

<img src="..\Linux命令行与shell脚本大全\img\脚本名2.png">

还有当传递给$0变量的实际字符串不仅仅是脚本名，而是完整脚本路径时，变量$0会使用整个路径。

>  解决方法：
>
> 命令basename会返回不包含路径的脚本名。

```bash
1	#!/bin/bash
2	
3	name=$( basename $0)
4	echo "The script name is : $name"
```

#### 14.1.3. 测试参数

当脚本中引用了命令行参数，但运行脚本时不提供时，bash会报语法错误。

可以使用-n测试来检测命令行参数$1中是否有数据。

```bash
1	#/bin/bash
2	
3	if [ -n "$1" ]
4	then
5		echo Hello $1, glad to meet you.
6	else 
7		echo "Sorry, you did not identify yourself."
8	fi
```

<img src="..\Linux命令行与shell脚本大全\img\测试参数.png">

### 14.2. 特殊参数变量

bash shell中有些特殊变量，会记录命令行参数。

#### 14.2.1. 参数统计

特殊变量$#用来统计命令行输入了多少个参数。

```bash
1	#!/bin/bash
2	
3	echo "This params is $#"    # 打印命令行参数个数 
```

配合test命令来检查参数个数。

```bash
1	#!/bin/bash
2	
3	if [ $# -ne 2 ]              # 检查入参个数
4	then
5		echo "参数个数因为2!"      # 入参个数有误时输出提示信息
6	else 
7		echo "sum = $[ $1 + $2 ]"
8	fi
```

\$#变量含有参数的总数，当\$#表示代表了最后一个命令行参数的变量，当没有参数时，$#代表脚本名。

```bash
1	#!/bin/bash
2	
3	params=$#         
4	echo "the params is $params"
5	echo "the script name is ${!#}"     #花括号中不能出现美元符，用！号代替
```

#### 14.2.2. 抓取所有参数

$*和$@变量可以访问所有参数。

```bash
1	#!/bin/bash
2	
3	echo "Using the \$* method: $*"
4	echo "Using the \$@ method: $@"
```

运行结果：

<img src="..\Linux命令行与shell脚本大全\img\抓取所有数据.png">

> $* 变量将所有参数当作一个单词保存，$*会将这些参数视为一个整体，而不是多个个体
>
> $@变量会将所有参数当做同一字符中的多个独立的单词，可以用for对其进行遍历

```bash
1	#!/bin/bash
2	
3	echo 
4	count=1
5	
6	for param in "$@"
7	do
8		echo "\$@ Parpameter #$count = $param"
9		count=$[ $count + 1 ]
10	done
```

运行结果：

<img src="..\Linux命令行与shell脚本大全\img\抓取所有数据2.png">

### 14.3. 移动变量

shift命令会根据他们的相对位置来移动命令行参数。

默认情况下它会将每个参数变量向左移动一个位置。所以变量\$3的值会移动到\$2中，\$2的值移动到\$1中，变量\$1的值会被删除，$0的变量值保持不变。

shift命令可以轻松跳过不需要的参数。

```bash
1	#!/bin/bash
2	
3	while [ -n "$1" ]
4	do
5		echo "param is $1"
6		shift
7	done
```

<img src="..\Linux命令行与shell脚本大全\img\shift.png">

一次移动多位

```bash
shift number  
```

### 14.4. 处理选项

#### 14.4.1. 查找选项

1. 处理简单选项

提取单个参数时，用case语句。

```bash
1	#!/bin/bash
2	echo
3	
4	while [ -n "$1" ]
5	do
6		case "$1" in  
7				-a) echo "Found the -a option" ;;       #  以后可以替换成相应的操作
8				-b) echo "Found the -b option" ;;
9				-c) echo "Found the -c option" ;;
10				*) echo "$1 is not an option" ;;
11		esac
12		shift
13	done
```

2. 分离参数和选项

 























































