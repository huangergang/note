单向链表实现

``` C
#ifndef _List_H
struct Node;
typedef struct Node* PtrToNode;
typedef PtrToNode List;
typedef PtrToNode Position;

List MakeEmpty(List L);
int IsEmpty(List L);
int IsLast(Position P, List L);
Position Find(int X, List L);
void Delete(int X, List L);
Position FindPrevious(int X, List L);
void Insert(int X, List L,Position p);
void DeleteList(List L);
Position Header(List L);
Position First(List L);
Position Advance(Position P);
int Retrieve(Position P);

#endif
```

~~~ C
#include<stdio.h>
#include<stdlib.h>
#include"List.h"
struct Node {
	int data;
	Position next;
};

List MakeEmpty() {
	List L = (List)malloc(sizeof(List));
	L->next = NULL;
	return  L;
}

int IsEmpty(List L) {
	return L->next == NULL;
}

int IsLast(Position P, List L) {
	return P->next == NULL;
}

Position FindPrevious(int X, List L) {
	Position p;
	p = L;
	while (p->next != NULL && p->next->data != X)
		p = p->next;
	return p;
}

Position Find(int X, List L) {
	Position p;
	p = L->next;
	while (p != NULL && p->data != X)
		p = p->next;
	return p;
}

void Delete(int X, List L) {
	Position p, TmpCall;
	p = FindPrevious(X, L);
	if (!IsLast(p, L)) {
		TmpCall = p->next;
		p->next = TmpCall->next;
		free(TmpCall);
	}
}

void Insert(int X, List L, Position p) {
	Position TmpCall;
	TmpCall = (Position)malloc(sizeof(struct Node));
	if (TmpCall == NULL)
	printf("Out of space!!!");
	TmpCall->data = X;
	TmpCall->next = p->next;
	p->next = TmpCall;
}

void DeleteList(List L) {
	Position p, Tmp;
	p = L->next;
	L->next = NULL;
	while (p != NULL)
	{
		Tmp = p->next;
		free(p);
		p = Tmp;
	}
}

void PrintList(List L) {
	Position p;
	p = L->next;
	while (p != NULL) {
		printf("%d ", p->data);
		p = p->next;
	}
	printf("\n");
}

int main() {
	List L = MakeEmpty();
	for (int i = 0; i < 10; i++)
	{
		int X = rand() % 10;
		Insert(X, L, L);
	}
	PrintList(L);
	return 0;
}
~~~

